import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class".
 */
private pattern mustInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class");
}

/**
 * An element may be an instance of type "NodeLabel class".
 */
private pattern mayInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class".
 */
private pattern mustInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class");
}

/**
 * An element may be an instance of type "PatternElementChain class".
 */
private pattern mayInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class".
 */
private pattern mustInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class");
}

/**
 * An element may be an instance of type "RelationshipPattern class".
 */
private pattern mayInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class".
 */
private pattern mustInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class");
}

/**
 * An element may be an instance of type "RelationshipDetail class".
 */
private pattern mayInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class".
 */
private pattern mustInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class");
}

/**
 * An element may be an instance of type "RelationshipTypes class".
 */
private pattern mayInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class DefinedPart".
 */
private pattern mustInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class DefinedPart");
}

/**
 * An element may be an instance of type "Match class DefinedPart".
 */
private pattern mayInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class UndefinedPart".
 */
private pattern mustInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class UndefinedPart");
}

/**
 * An element may be an instance of type "Match class UndefinedPart".
 */
private pattern mayInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class DefinedPart".
 */
private pattern mustInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class DefinedPart");
}

/**
 * An element may be an instance of type "Pattern class DefinedPart".
 */
private pattern mayInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class UndefinedPart".
 */
private pattern mustInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class UndefinedPart");
}

/**
 * An element may be an instance of type "Pattern class UndefinedPart".
 */
private pattern mayInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class DefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class DefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class DefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class DefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class DefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class DefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class DefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class UndefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class DefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class DefinedPart".
 */
private pattern mustInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class DefinedPart");
}

/**
 * An element may be an instance of type "Return class DefinedPart".
 */
private pattern mayInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class UndefinedPart".
 */
private pattern mustInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class UndefinedPart");
}

/**
 * An element may be an instance of type "Return class UndefinedPart".
 */
private pattern mayInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class DefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class DefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class DefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class DefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class DefinedPart".
 */
private pattern mustInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class DefinedPart");
}

/**
 * An element may be an instance of type "Query class DefinedPart".
 */
private pattern mayInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class UndefinedPart".
 */
private pattern mustInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class UndefinedPart");
}

/**
 * An element may be an instance of type "Query class UndefinedPart".
 */
private pattern mayInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class DefinedPart".
 */
private pattern mustInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class DefinedPart");
}

/**
 * An element may be an instance of type "Statement class DefinedPart".
 */
private pattern mayInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class UndefinedPart".
 */
private pattern mustInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class UndefinedPart");
}

/**
 * An element may be an instance of type "Statement class UndefinedPart".
 */
private pattern mayInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class DefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class UndefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class DefinedPart".
 */
private pattern mustInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class DefinedPart");
}

/**
 * An element may be an instance of type "Clause class DefinedPart".
 */
private pattern mayInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class UndefinedPart".
 */
private pattern mustInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class UndefinedPart");
}

/**
 * An element may be an instance of type "Clause class UndefinedPart".
 */
private pattern mayInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class DefinedPart".
 */
private pattern mustInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class DefinedPart");
}

/**
 * An element may be an instance of type "Properties class DefinedPart".
 */
private pattern mayInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class UndefinedPart".
 */
private pattern mustInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class UndefinedPart");
}

/**
 * An element may be an instance of type "Properties class UndefinedPart".
 */
private pattern mayInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class DefinedPart".
 */
private pattern mustInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class DefinedPart");
}

/**
 * An element may be an instance of type "Literal class DefinedPart".
 */
private pattern mayInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class UndefinedPart".
 */
private pattern mustInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class UndefinedPart");
}

/**
 * An element may be an instance of type "Literal class UndefinedPart".
 */
private pattern mayInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class DefinedPart".
 */
private pattern mustInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class DefinedPart");
}

/**
 * An element may be an instance of type "Expression class DefinedPart".
 */
private pattern mayInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class UndefinedPart".
 */
private pattern mustInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class UndefinedPart");
}

/**
 * An element may be an instance of type "Expression class UndefinedPart".
 */
private pattern mayInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class DefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class UndefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodeLabels reference NodeLabels(source,target)
 */
private pattern mustInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodeLabels reference NodeLabels");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodeLabels reference NodeLabels(source,target)
 */
private pattern mayInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodeLabels_class(problem,interpretation,source);
	find mayInstanceOfNodeLabel_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodePattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodePattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodePattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"relationshipPattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []detail reference RelationshipPattern(source,target)
 */
private pattern mustInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"detail reference RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>detail reference RelationshipPattern(source,target)
 */
private pattern mayInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference RelationshipDetail(source,target)
 */
private pattern mustInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference RelationshipDetail(source,target)
 */
private pattern mayInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference RelationshipDetail(source,target)
 */
private pattern mustInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference RelationshipDetail(source,target)
 */
private pattern mayInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []incoming attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incoming attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoing attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoing attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute RelationshipDetail(source,target)
 */
private pattern mustInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute RelationshipDetail(source,target)
 */
private pattern mayInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern validation hasReference
private pattern mustInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
private pattern mayInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mayInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mayInstanceOfExpression_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variRef);
}
private pattern currentInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
// Must, May and Current queries for pattern validation hasNoReference
private pattern mustInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mayInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern mayInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mustInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern currentInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find currentInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
// Must, May and Current queries for pattern validation wellLookingPattern
private pattern mustInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
private pattern mayInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_patternElement);
}
private pattern currentInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
// Must, May and Current queries for pattern validation wellLookingPatternElement
private pattern mustInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
private pattern mayInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodePattern);
}
private pattern currentInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
// Must, May and Current queries for pattern validation notWellLookingPatter
private pattern mustInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mayInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mustInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find currentInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
// Must, May and Current queries for pattern validation notWellLookingPatternElement
private pattern mustInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mayInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mustInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find currentInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
// Must, May and Current queries for pattern validation patternElementHasVar
private pattern mustInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
private pattern mayInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variable);
}
private pattern currentInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
// Must, May and Current queries for pattern validation patternElementHasPart
private pattern mustInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
private pattern mayInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_part);
}
private pattern currentInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
// Must, May and Current queries for pattern validation pe
private pattern mustInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern mayInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern currentInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
// Must, May and Current queries for pattern validation notPatternElement
private pattern mustInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mayInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern mayInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mustInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern currentInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find currentInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
// Must, May and Current queries for pattern validation notWellLookingMapliteral
private pattern mustInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}
private pattern mayInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodeLabel);
}
private pattern currentInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find mustInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find mustInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find mustInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern invalidatedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find mustInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern invalidatedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find mustInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern invalidatedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find mustInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern invalidatedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find mustInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_readingClauses_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_return_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_pattern_reference_Match(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_patterns_reference_Pattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpatterns_reference_Pattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_nodepattern_reference_PatternElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_properties_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variable_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_entries_reference_MapLiteral(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationentries_reference_MapLiteral(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_value_reference_MapLiteralEntry(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_body_reference_Return(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_returnItems_reference_ReturnBody(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_items_reference_ReturnItems(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationitems_reference_ReturnItems(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_expression_reference_ReturnItem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variableRef_reference_VariableRef(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustInstanceOfVariableRef_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find currentInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find currentInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find currentInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern unfinishedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find currentInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern unfinishedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find currentInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern unfinishedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find currentInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern unfinishedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find currentInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Match_class_UndefinedPart_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodePattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodePattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipTypes_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipTypes class UndefinedPart");
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class UndefinedPart");
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart_by_detail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"detail reference RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,container);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationdetail_reference_RelationshipPattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart_by_relationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"relationshipPattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class UndefinedPart");
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart_by_nodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodeLabels reference NodeLabels");
	find mustInstanceOfNodeLabels_class(problem,interpretation,container);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Match_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
pattern refineRelation_incoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_outgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class".
 */
private pattern mustInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class");
}

/**
 * An element may be an instance of type "NodeLabel class".
 */
private pattern mayInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class".
 */
private pattern mustInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class");
}

/**
 * An element may be an instance of type "PatternElementChain class".
 */
private pattern mayInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class".
 */
private pattern mustInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class");
}

/**
 * An element may be an instance of type "RelationshipPattern class".
 */
private pattern mayInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class".
 */
private pattern mustInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class");
}

/**
 * An element may be an instance of type "RelationshipDetail class".
 */
private pattern mayInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class".
 */
private pattern mustInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class");
}

/**
 * An element may be an instance of type "RelationshipTypes class".
 */
private pattern mayInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class DefinedPart".
 */
private pattern mustInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class DefinedPart");
}

/**
 * An element may be an instance of type "Match class DefinedPart".
 */
private pattern mayInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class UndefinedPart".
 */
private pattern mustInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class UndefinedPart");
}

/**
 * An element may be an instance of type "Match class UndefinedPart".
 */
private pattern mayInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class DefinedPart".
 */
private pattern mustInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class DefinedPart");
}

/**
 * An element may be an instance of type "Pattern class DefinedPart".
 */
private pattern mayInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class UndefinedPart".
 */
private pattern mustInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class UndefinedPart");
}

/**
 * An element may be an instance of type "Pattern class UndefinedPart".
 */
private pattern mayInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class DefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class DefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class DefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class DefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class DefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class DefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class DefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class UndefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class DefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class DefinedPart".
 */
private pattern mustInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class DefinedPart");
}

/**
 * An element may be an instance of type "Return class DefinedPart".
 */
private pattern mayInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class UndefinedPart".
 */
private pattern mustInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class UndefinedPart");
}

/**
 * An element may be an instance of type "Return class UndefinedPart".
 */
private pattern mayInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class DefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class DefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class DefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class DefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class DefinedPart".
 */
private pattern mustInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class DefinedPart");
}

/**
 * An element may be an instance of type "Query class DefinedPart".
 */
private pattern mayInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class UndefinedPart".
 */
private pattern mustInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class UndefinedPart");
}

/**
 * An element may be an instance of type "Query class UndefinedPart".
 */
private pattern mayInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class DefinedPart".
 */
private pattern mustInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class DefinedPart");
}

/**
 * An element may be an instance of type "Statement class DefinedPart".
 */
private pattern mayInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class UndefinedPart".
 */
private pattern mustInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class UndefinedPart");
}

/**
 * An element may be an instance of type "Statement class UndefinedPart".
 */
private pattern mayInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class DefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class UndefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class DefinedPart".
 */
private pattern mustInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class DefinedPart");
}

/**
 * An element may be an instance of type "Clause class DefinedPart".
 */
private pattern mayInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class UndefinedPart".
 */
private pattern mustInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class UndefinedPart");
}

/**
 * An element may be an instance of type "Clause class UndefinedPart".
 */
private pattern mayInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class DefinedPart".
 */
private pattern mustInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class DefinedPart");
}

/**
 * An element may be an instance of type "Properties class DefinedPart".
 */
private pattern mayInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class UndefinedPart".
 */
private pattern mustInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class UndefinedPart");
}

/**
 * An element may be an instance of type "Properties class UndefinedPart".
 */
private pattern mayInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class DefinedPart".
 */
private pattern mustInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class DefinedPart");
}

/**
 * An element may be an instance of type "Literal class DefinedPart".
 */
private pattern mayInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class UndefinedPart".
 */
private pattern mustInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class UndefinedPart");
}

/**
 * An element may be an instance of type "Literal class UndefinedPart".
 */
private pattern mayInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class DefinedPart".
 */
private pattern mustInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class DefinedPart");
}

/**
 * An element may be an instance of type "Expression class DefinedPart".
 */
private pattern mayInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class UndefinedPart".
 */
private pattern mustInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class UndefinedPart");
}

/**
 * An element may be an instance of type "Expression class UndefinedPart".
 */
private pattern mayInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class DefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class UndefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodeLabels reference NodeLabels(source,target)
 */
private pattern mustInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodeLabels reference NodeLabels");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodeLabels reference NodeLabels(source,target)
 */
private pattern mayInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodeLabels_class(problem,interpretation,source);
	find mayInstanceOfNodeLabel_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodePattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodePattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodePattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"relationshipPattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []detail reference RelationshipPattern(source,target)
 */
private pattern mustInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"detail reference RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>detail reference RelationshipPattern(source,target)
 */
private pattern mayInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference RelationshipDetail(source,target)
 */
private pattern mustInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference RelationshipDetail(source,target)
 */
private pattern mayInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference RelationshipDetail(source,target)
 */
private pattern mustInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference RelationshipDetail(source,target)
 */
private pattern mayInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []chain reference PatternElement(source,target)
 */
private pattern mustInRelationchain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"chain reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>chain reference PatternElement(source,target)
 */
private pattern mayInRelationchain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfPatternElementChain_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationchain_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []incoming attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incoming attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoing attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoing attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute RelationshipDetail(source,target)
 */
private pattern mustInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute RelationshipDetail(source,target)
 */
private pattern mayInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern validation hasReference
private pattern mustInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
private pattern mayInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mayInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mayInstanceOfExpression_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variRef);
}
private pattern currentInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
// Must, May and Current queries for pattern validation hasNoReference
private pattern mustInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mayInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern mayInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mustInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern currentInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find currentInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
// Must, May and Current queries for pattern validation wellLookingPattern
private pattern mustInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
private pattern mayInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_patternElement);
}
private pattern currentInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
// Must, May and Current queries for pattern validation wellLookingPatternElement
private pattern mustInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
private pattern mayInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodePattern);
}
private pattern currentInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
// Must, May and Current queries for pattern validation notWellLookingPatter
private pattern mustInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mayInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mustInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find currentInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
// Must, May and Current queries for pattern validation notWellLookingPatternElement
private pattern mustInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mayInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mustInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find currentInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
// Must, May and Current queries for pattern validation patternElementHasVar
private pattern mustInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
private pattern mayInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variable);
}
private pattern currentInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
// Must, May and Current queries for pattern validation patternElementHasPart
private pattern mustInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
private pattern mayInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_part);
}
private pattern currentInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
// Must, May and Current queries for pattern validation pe
private pattern mustInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern mayInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern currentInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
// Must, May and Current queries for pattern validation notPatternElement
private pattern mustInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mayInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern mayInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mustInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern currentInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find currentInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
// Must, May and Current queries for pattern validation notWellLookingMapliteral
private pattern mustInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}
private pattern mayInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodeLabel);
}
private pattern currentInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationchain_reference_PatternElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find mustInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find mustInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find mustInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern invalidatedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find mustInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern invalidatedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find mustInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern invalidatedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find mustInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern invalidatedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find mustInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_readingClauses_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_return_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_pattern_reference_Match(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_patterns_reference_Pattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpatterns_reference_Pattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_nodepattern_reference_PatternElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_properties_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variable_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_entries_reference_MapLiteral(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationentries_reference_MapLiteral(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_value_reference_MapLiteralEntry(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_body_reference_Return(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_returnItems_reference_ReturnBody(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_items_reference_ReturnItems(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationitems_reference_ReturnItems(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_expression_reference_ReturnItem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variableRef_reference_VariableRef(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustInstanceOfVariableRef_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find currentInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find currentInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find currentInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern unfinishedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find currentInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern unfinishedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find currentInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern unfinishedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find currentInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern unfinishedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find currentInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_SingleQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart_by_relationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"relationshipPattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class UndefinedPart");
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart_by_nodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodeLabels reference NodeLabels");
	find mustInstanceOfNodeLabels_class(problem,interpretation,container);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart_by_chain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"chain reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationchain_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class UndefinedPart");
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodePattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodePattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart_by_detail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"detail reference RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,container);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationdetail_reference_RelationshipPattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipTypes_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipTypes class UndefinedPart");
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_SingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
pattern refineRelation_incoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_outgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class".
 */
private pattern mustInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class");
}

/**
 * An element may be an instance of type "NodeLabel class".
 */
private pattern mayInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class".
 */
private pattern mustInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class");
}

/**
 * An element may be an instance of type "PatternElementChain class".
 */
private pattern mayInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class".
 */
private pattern mustInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class");
}

/**
 * An element may be an instance of type "RelationshipPattern class".
 */
private pattern mayInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class".
 */
private pattern mustInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class");
}

/**
 * An element may be an instance of type "RelationshipDetail class".
 */
private pattern mayInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class".
 */
private pattern mustInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class");
}

/**
 * An element may be an instance of type "RelationshipTypes class".
 */
private pattern mayInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class DefinedPart".
 */
private pattern mustInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class DefinedPart");
}

/**
 * An element may be an instance of type "Match class DefinedPart".
 */
private pattern mayInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class UndefinedPart".
 */
private pattern mustInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class UndefinedPart");
}

/**
 * An element may be an instance of type "Match class UndefinedPart".
 */
private pattern mayInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class DefinedPart".
 */
private pattern mustInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class DefinedPart");
}

/**
 * An element may be an instance of type "Pattern class DefinedPart".
 */
private pattern mayInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class UndefinedPart".
 */
private pattern mustInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class UndefinedPart");
}

/**
 * An element may be an instance of type "Pattern class UndefinedPart".
 */
private pattern mayInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class DefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class DefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class DefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class DefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class DefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class DefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class DefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class UndefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class DefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class DefinedPart".
 */
private pattern mustInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class DefinedPart");
}

/**
 * An element may be an instance of type "Return class DefinedPart".
 */
private pattern mayInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class UndefinedPart".
 */
private pattern mustInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class UndefinedPart");
}

/**
 * An element may be an instance of type "Return class UndefinedPart".
 */
private pattern mayInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class DefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class DefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class DefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class DefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class DefinedPart".
 */
private pattern mustInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class DefinedPart");
}

/**
 * An element may be an instance of type "Query class DefinedPart".
 */
private pattern mayInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class UndefinedPart".
 */
private pattern mustInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class UndefinedPart");
}

/**
 * An element may be an instance of type "Query class UndefinedPart".
 */
private pattern mayInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class DefinedPart".
 */
private pattern mustInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class DefinedPart");
}

/**
 * An element may be an instance of type "Statement class DefinedPart".
 */
private pattern mayInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class UndefinedPart".
 */
private pattern mustInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class UndefinedPart");
}

/**
 * An element may be an instance of type "Statement class UndefinedPart".
 */
private pattern mayInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class DefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class UndefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class DefinedPart".
 */
private pattern mustInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class DefinedPart");
}

/**
 * An element may be an instance of type "Clause class DefinedPart".
 */
private pattern mayInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class UndefinedPart".
 */
private pattern mustInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class UndefinedPart");
}

/**
 * An element may be an instance of type "Clause class UndefinedPart".
 */
private pattern mayInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class DefinedPart".
 */
private pattern mustInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class DefinedPart");
}

/**
 * An element may be an instance of type "Properties class DefinedPart".
 */
private pattern mayInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class UndefinedPart".
 */
private pattern mustInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class UndefinedPart");
}

/**
 * An element may be an instance of type "Properties class UndefinedPart".
 */
private pattern mayInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class DefinedPart".
 */
private pattern mustInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class DefinedPart");
}

/**
 * An element may be an instance of type "Literal class DefinedPart".
 */
private pattern mayInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class UndefinedPart".
 */
private pattern mustInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class UndefinedPart");
}

/**
 * An element may be an instance of type "Literal class UndefinedPart".
 */
private pattern mayInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class DefinedPart".
 */
private pattern mustInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class DefinedPart");
}

/**
 * An element may be an instance of type "Expression class DefinedPart".
 */
private pattern mayInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class UndefinedPart".
 */
private pattern mustInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class UndefinedPart");
}

/**
 * An element may be an instance of type "Expression class UndefinedPart".
 */
private pattern mayInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class DefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class UndefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodeLabels reference NodeLabels(source,target)
 */
private pattern mustInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodeLabels reference NodeLabels");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodeLabels reference NodeLabels(source,target)
 */
private pattern mayInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodeLabels_class(problem,interpretation,source);
	find mayInstanceOfNodeLabel_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodePattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodePattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodePattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"relationshipPattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []detail reference RelationshipPattern(source,target)
 */
private pattern mustInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"detail reference RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>detail reference RelationshipPattern(source,target)
 */
private pattern mayInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference RelationshipDetail(source,target)
 */
private pattern mustInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference RelationshipDetail(source,target)
 */
private pattern mayInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference RelationshipDetail(source,target)
 */
private pattern mustInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference RelationshipDetail(source,target)
 */
private pattern mayInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []chain reference PatternElement(source,target)
 */
private pattern mustInRelationchain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"chain reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>chain reference PatternElement(source,target)
 */
private pattern mayInRelationchain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfPatternElementChain_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationchain_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []incoming attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incoming attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoing attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoing attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute RelationshipDetail(source,target)
 */
private pattern mustInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute RelationshipDetail(source,target)
 */
private pattern mayInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern validation hasReference
private pattern mustInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
private pattern mayInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mayInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mayInstanceOfExpression_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variRef);
}
private pattern currentInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
// Must, May and Current queries for pattern validation hasNoReference
private pattern mustInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mayInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern mayInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mustInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern currentInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find currentInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
// Must, May and Current queries for pattern validation wellLookingPattern
private pattern mustInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
private pattern mayInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_patternElement);
}
private pattern currentInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
// Must, May and Current queries for pattern validation wellLookingPatternElement
private pattern mustInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
private pattern mayInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodePattern);
}
private pattern currentInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
// Must, May and Current queries for pattern validation notWellLookingPatter
private pattern mustInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mayInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mustInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find currentInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
// Must, May and Current queries for pattern validation notWellLookingPatternElement
private pattern mustInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mayInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mustInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find currentInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
// Must, May and Current queries for pattern validation patternElementHasVar
private pattern mustInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
private pattern mayInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variable);
}
private pattern currentInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
// Must, May and Current queries for pattern validation patternElementHasPart
private pattern mustInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
private pattern mayInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_part);
}
private pattern currentInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
// Must, May and Current queries for pattern validation pe
private pattern mustInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern mayInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern currentInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
// Must, May and Current queries for pattern validation notPatternElement
private pattern mustInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mayInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern mayInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mustInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern currentInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find currentInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
// Must, May and Current queries for pattern validation notWellLookingMapliteral
private pattern mustInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}
private pattern mayInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodeLabel);
}
private pattern currentInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationchain_reference_PatternElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find mustInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find mustInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find mustInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern invalidatedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find mustInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern invalidatedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find mustInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern invalidatedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find mustInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern invalidatedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find mustInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_readingClauses_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_return_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_pattern_reference_Match(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_patterns_reference_Pattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpatterns_reference_Pattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_nodepattern_reference_PatternElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_properties_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variable_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_entries_reference_MapLiteral(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationentries_reference_MapLiteral(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_value_reference_MapLiteralEntry(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_body_reference_Return(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_returnItems_reference_ReturnBody(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_items_reference_ReturnItems(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationitems_reference_ReturnItems(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_expression_reference_ReturnItem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variableRef_reference_VariableRef(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustInstanceOfVariableRef_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_nodePattern_reference_PatternElementChain(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodePattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_relationshipPattern_reference_PatternElementChain(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"relationshipPattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_detail_reference_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"detail reference RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_incoming_attribute_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_outgoing_attribute_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find currentInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find currentInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find currentInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern unfinishedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find currentInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern unfinishedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find currentInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern unfinishedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find currentInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern unfinishedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find currentInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodePattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodePattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class UndefinedPart");
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class UndefinedPart");
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipTypes_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipTypes class UndefinedPart");
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart_by_relationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"relationshipPattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart_by_detail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"detail reference RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,container);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationdetail_reference_RelationshipPattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart_by_chain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"chain reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationchain_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart_by_nodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodeLabels reference NodeLabels");
	find mustInstanceOfNodeLabels_class(problem,interpretation,container);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_NodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_Return_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
pattern refineRelation_incoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_outgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class".
 */
private pattern mustInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class");
}

/**
 * An element may be an instance of type "NodeLabel class".
 */
private pattern mayInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class".
 */
private pattern mustInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class");
}

/**
 * An element may be an instance of type "PatternElementChain class".
 */
private pattern mayInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class".
 */
private pattern mustInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class");
}

/**
 * An element may be an instance of type "RelationshipPattern class".
 */
private pattern mayInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class".
 */
private pattern mustInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class");
}

/**
 * An element may be an instance of type "RelationshipDetail class".
 */
private pattern mayInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class".
 */
private pattern mustInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class");
}

/**
 * An element may be an instance of type "RelationshipTypes class".
 */
private pattern mayInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class DefinedPart".
 */
private pattern mustInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class DefinedPart");
}

/**
 * An element may be an instance of type "Match class DefinedPart".
 */
private pattern mayInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class UndefinedPart".
 */
private pattern mustInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class UndefinedPart");
}

/**
 * An element may be an instance of type "Match class UndefinedPart".
 */
private pattern mayInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class DefinedPart".
 */
private pattern mustInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class DefinedPart");
}

/**
 * An element may be an instance of type "Pattern class DefinedPart".
 */
private pattern mayInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class UndefinedPart".
 */
private pattern mustInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class UndefinedPart");
}

/**
 * An element may be an instance of type "Pattern class UndefinedPart".
 */
private pattern mayInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class DefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class DefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class DefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class DefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class DefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class DefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class DefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class UndefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class DefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class DefinedPart".
 */
private pattern mustInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class DefinedPart");
}

/**
 * An element may be an instance of type "Return class DefinedPart".
 */
private pattern mayInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class UndefinedPart".
 */
private pattern mustInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class UndefinedPart");
}

/**
 * An element may be an instance of type "Return class UndefinedPart".
 */
private pattern mayInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class DefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class DefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class DefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class DefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class DefinedPart".
 */
private pattern mustInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class DefinedPart");
}

/**
 * An element may be an instance of type "Query class DefinedPart".
 */
private pattern mayInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class UndefinedPart".
 */
private pattern mustInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class UndefinedPart");
}

/**
 * An element may be an instance of type "Query class UndefinedPart".
 */
private pattern mayInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class DefinedPart".
 */
private pattern mustInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class DefinedPart");
}

/**
 * An element may be an instance of type "Statement class DefinedPart".
 */
private pattern mayInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class UndefinedPart".
 */
private pattern mustInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class UndefinedPart");
}

/**
 * An element may be an instance of type "Statement class UndefinedPart".
 */
private pattern mayInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class DefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class UndefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class DefinedPart".
 */
private pattern mustInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class DefinedPart");
}

/**
 * An element may be an instance of type "Clause class DefinedPart".
 */
private pattern mayInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class UndefinedPart".
 */
private pattern mustInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class UndefinedPart");
}

/**
 * An element may be an instance of type "Clause class UndefinedPart".
 */
private pattern mayInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class DefinedPart".
 */
private pattern mustInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class DefinedPart");
}

/**
 * An element may be an instance of type "Properties class DefinedPart".
 */
private pattern mayInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class UndefinedPart".
 */
private pattern mustInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class UndefinedPart");
}

/**
 * An element may be an instance of type "Properties class UndefinedPart".
 */
private pattern mayInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class DefinedPart".
 */
private pattern mustInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class DefinedPart");
}

/**
 * An element may be an instance of type "Literal class DefinedPart".
 */
private pattern mayInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class UndefinedPart".
 */
private pattern mustInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class UndefinedPart");
}

/**
 * An element may be an instance of type "Literal class UndefinedPart".
 */
private pattern mayInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class DefinedPart".
 */
private pattern mustInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class DefinedPart");
}

/**
 * An element may be an instance of type "Expression class DefinedPart".
 */
private pattern mayInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class UndefinedPart".
 */
private pattern mustInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class UndefinedPart");
}

/**
 * An element may be an instance of type "Expression class UndefinedPart".
 */
private pattern mayInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class DefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class UndefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 2);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodeLabels reference NodeLabels(source,target)
 */
private pattern mustInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodeLabels reference NodeLabels");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodeLabels reference NodeLabels(source,target)
 */
private pattern mayInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodeLabels_class(problem,interpretation,source);
	find mayInstanceOfNodeLabel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,_);
	check(numberOfExistingReferences < 2);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodePattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodePattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodePattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"relationshipPattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []detail reference RelationshipPattern(source,target)
 */
private pattern mustInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"detail reference RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>detail reference RelationshipPattern(source,target)
 */
private pattern mayInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference RelationshipDetail(source,target)
 */
private pattern mustInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference RelationshipDetail(source,target)
 */
private pattern mayInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference RelationshipDetail(source,target)
 */
private pattern mustInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference RelationshipDetail(source,target)
 */
private pattern mayInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []chain reference PatternElement(source,target)
 */
private pattern mustInRelationchain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"chain reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>chain reference PatternElement(source,target)
 */
private pattern mayInRelationchain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfPatternElementChain_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationchain_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []incoming attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incoming attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoing attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoing attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute RelationshipDetail(source,target)
 */
private pattern mustInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute RelationshipDetail(source,target)
 */
private pattern mayInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern validation hasReference
private pattern mustInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
private pattern mayInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mayInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mayInstanceOfExpression_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variRef);
}
private pattern currentInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
// Must, May and Current queries for pattern validation hasNoReference
private pattern mustInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mayInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern mayInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mustInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern currentInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find currentInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
// Must, May and Current queries for pattern validation wellLookingPattern
private pattern mustInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
private pattern mayInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_patternElement);
}
private pattern currentInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
// Must, May and Current queries for pattern validation wellLookingPatternElement
private pattern mustInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
private pattern mayInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodePattern);
}
private pattern currentInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
// Must, May and Current queries for pattern validation notWellLookingPatter
private pattern mustInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mayInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mustInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find currentInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
// Must, May and Current queries for pattern validation notWellLookingPatternElement
private pattern mustInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mayInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mustInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find currentInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
// Must, May and Current queries for pattern validation patternElementHasVar
private pattern mustInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
private pattern mayInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variable);
}
private pattern currentInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
// Must, May and Current queries for pattern validation patternElementHasPart
private pattern mustInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
private pattern mayInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_part);
}
private pattern currentInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
// Must, May and Current queries for pattern validation pe
private pattern mustInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern mayInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern currentInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
// Must, May and Current queries for pattern validation notPatternElement
private pattern mustInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mayInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern mayInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mustInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern currentInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find currentInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
// Must, May and Current queries for pattern validation notWellLookingMapliteral
private pattern mustInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}
private pattern mayInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodeLabel);
}
private pattern currentInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationchain_reference_PatternElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find mustInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find mustInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find mustInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern invalidatedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find mustInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern invalidatedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find mustInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern invalidatedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find mustInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern invalidatedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find mustInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_readingClauses_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_return_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_pattern_reference_Match(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_patterns_reference_Pattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpatterns_reference_Pattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_nodepattern_reference_PatternElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_properties_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variable_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_entries_reference_MapLiteral(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationentries_reference_MapLiteral(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_value_reference_MapLiteralEntry(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_body_reference_Return(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_returnItems_reference_ReturnBody(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_items_reference_ReturnItems(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationitems_reference_ReturnItems(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_expression_reference_ReturnItem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variableRef_reference_VariableRef(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustInstanceOfVariableRef_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_nodePattern_reference_PatternElementChain(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodePattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_relationshipPattern_reference_PatternElementChain(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"relationshipPattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_detail_reference_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"detail reference RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_incoming_attribute_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_outgoing_attribute_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find currentInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find currentInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find currentInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern unfinishedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find currentInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern unfinishedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find currentInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern unfinishedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find currentInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern unfinishedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find currentInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart_by_detail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"detail reference RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,container);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationdetail_reference_RelationshipPattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class UndefinedPart");
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipTypes_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipTypes class UndefinedPart");
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart_by_chain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"chain reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationchain_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class UndefinedPart");
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart_by_nodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodeLabels reference NodeLabels");
	find mustInstanceOfNodeLabels_class(problem,interpretation,container);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart_by_relationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"relationshipPattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodePattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodePattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_MapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
pattern refineRelation_incoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_outgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class".
 */
private pattern mustInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class");
}

/**
 * An element may be an instance of type "NodeLabel class".
 */
private pattern mayInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class".
 */
private pattern mustInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class");
}

/**
 * An element may be an instance of type "PatternElementChain class".
 */
private pattern mayInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class".
 */
private pattern mustInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class");
}

/**
 * An element may be an instance of type "RelationshipPattern class".
 */
private pattern mayInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class".
 */
private pattern mustInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class");
}

/**
 * An element may be an instance of type "RelationshipDetail class".
 */
private pattern mayInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class".
 */
private pattern mustInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class");
}

/**
 * An element may be an instance of type "RelationshipTypes class".
 */
private pattern mayInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class DefinedPart".
 */
private pattern mustInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class DefinedPart");
}

/**
 * An element may be an instance of type "Match class DefinedPart".
 */
private pattern mayInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class UndefinedPart".
 */
private pattern mustInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class UndefinedPart");
}

/**
 * An element may be an instance of type "Match class UndefinedPart".
 */
private pattern mayInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class DefinedPart".
 */
private pattern mustInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class DefinedPart");
}

/**
 * An element may be an instance of type "Pattern class DefinedPart".
 */
private pattern mayInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class UndefinedPart".
 */
private pattern mustInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class UndefinedPart");
}

/**
 * An element may be an instance of type "Pattern class UndefinedPart".
 */
private pattern mayInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class DefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class DefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class DefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class DefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class DefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class DefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class DefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class UndefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class DefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class DefinedPart".
 */
private pattern mustInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class DefinedPart");
}

/**
 * An element may be an instance of type "Return class DefinedPart".
 */
private pattern mayInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class UndefinedPart".
 */
private pattern mustInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class UndefinedPart");
}

/**
 * An element may be an instance of type "Return class UndefinedPart".
 */
private pattern mayInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class DefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class DefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class DefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class DefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class DefinedPart".
 */
private pattern mustInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class DefinedPart");
}

/**
 * An element may be an instance of type "Query class DefinedPart".
 */
private pattern mayInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class UndefinedPart".
 */
private pattern mustInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class UndefinedPart");
}

/**
 * An element may be an instance of type "Query class UndefinedPart".
 */
private pattern mayInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class DefinedPart".
 */
private pattern mustInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class DefinedPart");
}

/**
 * An element may be an instance of type "Statement class DefinedPart".
 */
private pattern mayInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class UndefinedPart".
 */
private pattern mustInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class UndefinedPart");
}

/**
 * An element may be an instance of type "Statement class UndefinedPart".
 */
private pattern mayInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class DefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class UndefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class DefinedPart".
 */
private pattern mustInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class DefinedPart");
}

/**
 * An element may be an instance of type "Clause class DefinedPart".
 */
private pattern mayInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class UndefinedPart".
 */
private pattern mustInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class UndefinedPart");
}

/**
 * An element may be an instance of type "Clause class UndefinedPart".
 */
private pattern mayInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class DefinedPart".
 */
private pattern mustInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class DefinedPart");
}

/**
 * An element may be an instance of type "Properties class DefinedPart".
 */
private pattern mayInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class UndefinedPart".
 */
private pattern mustInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class UndefinedPart");
}

/**
 * An element may be an instance of type "Properties class UndefinedPart".
 */
private pattern mayInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class DefinedPart".
 */
private pattern mustInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class DefinedPart");
}

/**
 * An element may be an instance of type "Literal class DefinedPart".
 */
private pattern mayInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class UndefinedPart".
 */
private pattern mustInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class UndefinedPart");
}

/**
 * An element may be an instance of type "Literal class UndefinedPart".
 */
private pattern mayInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class DefinedPart".
 */
private pattern mustInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class DefinedPart");
}

/**
 * An element may be an instance of type "Expression class DefinedPart".
 */
private pattern mayInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class UndefinedPart".
 */
private pattern mustInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class UndefinedPart");
}

/**
 * An element may be an instance of type "Expression class UndefinedPart".
 */
private pattern mayInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class DefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class UndefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 2);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodeLabels reference NodeLabels(source,target)
 */
private pattern mustInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodeLabels reference NodeLabels");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodeLabels reference NodeLabels(source,target)
 */
private pattern mayInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodeLabels_class(problem,interpretation,source);
	find mayInstanceOfNodeLabel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,_);
	check(numberOfExistingReferences < 2);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodePattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodePattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodePattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"relationshipPattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []detail reference RelationshipPattern(source,target)
 */
private pattern mustInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"detail reference RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>detail reference RelationshipPattern(source,target)
 */
private pattern mayInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference RelationshipDetail(source,target)
 */
private pattern mustInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference RelationshipDetail(source,target)
 */
private pattern mayInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference RelationshipDetail(source,target)
 */
private pattern mustInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference RelationshipDetail(source,target)
 */
private pattern mayInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []chain reference PatternElement(source,target)
 */
private pattern mustInRelationchain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"chain reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>chain reference PatternElement(source,target)
 */
private pattern mayInRelationchain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfPatternElementChain_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationchain_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []incoming attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incoming attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoing attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoing attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute RelationshipDetail(source,target)
 */
private pattern mustInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute RelationshipDetail(source,target)
 */
private pattern mayInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern validation hasReference
private pattern mustInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
private pattern mayInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mayInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mayInstanceOfExpression_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variRef);
}
private pattern currentInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
// Must, May and Current queries for pattern validation hasNoReference
private pattern mustInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mayInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern mayInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mustInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern currentInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find currentInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
// Must, May and Current queries for pattern validation wellLookingPattern
private pattern mustInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
private pattern mayInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_patternElement);
}
private pattern currentInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
// Must, May and Current queries for pattern validation wellLookingPatternElement
private pattern mustInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
private pattern mayInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodePattern);
}
private pattern currentInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
// Must, May and Current queries for pattern validation notWellLookingPatter
private pattern mustInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mayInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mustInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find currentInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
// Must, May and Current queries for pattern validation notWellLookingPatternElement
private pattern mustInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mayInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mustInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find currentInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
// Must, May and Current queries for pattern validation patternElementHasVar
private pattern mustInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
private pattern mayInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variable);
}
private pattern currentInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
// Must, May and Current queries for pattern validation patternElementHasPart
private pattern mustInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
private pattern mayInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_part);
}
private pattern currentInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
// Must, May and Current queries for pattern validation pe
private pattern mustInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern mayInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern currentInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
// Must, May and Current queries for pattern validation notPatternElement
private pattern mustInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mayInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern mayInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mustInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern currentInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find currentInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
// Must, May and Current queries for pattern validation notWellLookingMapliteral
private pattern mustInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}
private pattern mayInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodeLabel);
}
private pattern currentInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationchain_reference_PatternElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find mustInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find mustInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find mustInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern invalidatedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find mustInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern invalidatedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find mustInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern invalidatedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find mustInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern invalidatedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find mustInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_readingClauses_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_return_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_pattern_reference_Match(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_patterns_reference_Pattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpatterns_reference_Pattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_nodepattern_reference_PatternElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_properties_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variable_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_entries_reference_MapLiteral(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationentries_reference_MapLiteral(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_value_reference_MapLiteralEntry(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_body_reference_Return(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_returnItems_reference_ReturnBody(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_items_reference_ReturnItems(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationitems_reference_ReturnItems(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_expression_reference_ReturnItem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variableRef_reference_VariableRef(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustInstanceOfVariableRef_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_nodePattern_reference_PatternElementChain(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodePattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_relationshipPattern_reference_PatternElementChain(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"relationshipPattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_detail_reference_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"detail reference RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_incoming_attribute_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_outgoing_attribute_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find currentInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find currentInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find currentInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern unfinishedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find currentInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern unfinishedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find currentInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern unfinishedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find currentInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern unfinishedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find currentInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodePattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodePattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class UndefinedPart");
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipTypes_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipTypes class UndefinedPart");
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart_by_detail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"detail reference RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,container);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationdetail_reference_RelationshipPattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart_by_chain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"chain reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationchain_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart_by_nodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodeLabels reference NodeLabels");
	find mustInstanceOfNodeLabels_class(problem,interpretation,container);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart_by_relationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"relationshipPattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class UndefinedPart");
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_NodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_PatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
pattern refineRelation_incoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_outgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class".
 */
private pattern mustInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class");
}

/**
 * An element may be an instance of type "NodeLabel class".
 */
private pattern mayInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class".
 */
private pattern mustInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class");
}

/**
 * An element may be an instance of type "PatternElementChain class".
 */
private pattern mayInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class".
 */
private pattern mustInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class");
}

/**
 * An element may be an instance of type "RelationshipPattern class".
 */
private pattern mayInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class".
 */
private pattern mustInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class");
}

/**
 * An element may be an instance of type "RelationshipDetail class".
 */
private pattern mayInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class".
 */
private pattern mustInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class");
}

/**
 * An element may be an instance of type "RelationshipTypes class".
 */
private pattern mayInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class DefinedPart".
 */
private pattern mustInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class DefinedPart");
}

/**
 * An element may be an instance of type "Match class DefinedPart".
 */
private pattern mayInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class UndefinedPart".
 */
private pattern mustInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class UndefinedPart");
}

/**
 * An element may be an instance of type "Match class UndefinedPart".
 */
private pattern mayInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class DefinedPart".
 */
private pattern mustInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class DefinedPart");
}

/**
 * An element may be an instance of type "Pattern class DefinedPart".
 */
private pattern mayInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class UndefinedPart".
 */
private pattern mustInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class UndefinedPart");
}

/**
 * An element may be an instance of type "Pattern class UndefinedPart".
 */
private pattern mayInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class DefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class DefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class DefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class DefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class DefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class DefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class DefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class UndefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class DefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class DefinedPart".
 */
private pattern mustInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class DefinedPart");
}

/**
 * An element may be an instance of type "Return class DefinedPart".
 */
private pattern mayInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class UndefinedPart".
 */
private pattern mustInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class UndefinedPart");
}

/**
 * An element may be an instance of type "Return class UndefinedPart".
 */
private pattern mayInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class DefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class DefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class DefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class DefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class DefinedPart".
 */
private pattern mustInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class DefinedPart");
}

/**
 * An element may be an instance of type "Query class DefinedPart".
 */
private pattern mayInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class UndefinedPart".
 */
private pattern mustInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class UndefinedPart");
}

/**
 * An element may be an instance of type "Query class UndefinedPart".
 */
private pattern mayInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class DefinedPart".
 */
private pattern mustInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class DefinedPart");
}

/**
 * An element may be an instance of type "Statement class DefinedPart".
 */
private pattern mayInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class UndefinedPart".
 */
private pattern mustInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class UndefinedPart");
}

/**
 * An element may be an instance of type "Statement class UndefinedPart".
 */
private pattern mayInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class DefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class UndefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class DefinedPart".
 */
private pattern mustInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class DefinedPart");
}

/**
 * An element may be an instance of type "Clause class DefinedPart".
 */
private pattern mayInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class UndefinedPart".
 */
private pattern mustInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class UndefinedPart");
}

/**
 * An element may be an instance of type "Clause class UndefinedPart".
 */
private pattern mayInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class DefinedPart".
 */
private pattern mustInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class DefinedPart");
}

/**
 * An element may be an instance of type "Properties class DefinedPart".
 */
private pattern mayInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class UndefinedPart".
 */
private pattern mustInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class UndefinedPart");
}

/**
 * An element may be an instance of type "Properties class UndefinedPart".
 */
private pattern mayInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class DefinedPart".
 */
private pattern mustInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class DefinedPart");
}

/**
 * An element may be an instance of type "Literal class DefinedPart".
 */
private pattern mayInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class UndefinedPart".
 */
private pattern mustInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class UndefinedPart");
}

/**
 * An element may be an instance of type "Literal class UndefinedPart".
 */
private pattern mayInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class DefinedPart".
 */
private pattern mustInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class DefinedPart");
}

/**
 * An element may be an instance of type "Expression class DefinedPart".
 */
private pattern mayInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class UndefinedPart".
 */
private pattern mustInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class UndefinedPart");
}

/**
 * An element may be an instance of type "Expression class UndefinedPart".
 */
private pattern mayInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class DefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class UndefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 2);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodeLabels reference NodeLabels(source,target)
 */
private pattern mustInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodeLabels reference NodeLabels");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodeLabels reference NodeLabels(source,target)
 */
private pattern mayInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodeLabels_class(problem,interpretation,source);
	find mayInstanceOfNodeLabel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,_);
	check(numberOfExistingReferences < 2);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodePattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodePattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodePattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"relationshipPattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []detail reference RelationshipPattern(source,target)
 */
private pattern mustInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"detail reference RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>detail reference RelationshipPattern(source,target)
 */
private pattern mayInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference RelationshipDetail(source,target)
 */
private pattern mustInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference RelationshipDetail(source,target)
 */
private pattern mayInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference RelationshipDetail(source,target)
 */
private pattern mustInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference RelationshipDetail(source,target)
 */
private pattern mayInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []chain reference PatternElement(source,target)
 */
private pattern mustInRelationchain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"chain reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>chain reference PatternElement(source,target)
 */
private pattern mayInRelationchain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfPatternElementChain_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationchain_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []incoming attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incoming attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoing attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoing attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute RelationshipDetail(source,target)
 */
private pattern mustInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute RelationshipDetail(source,target)
 */
private pattern mayInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern validation hasReference
private pattern mustInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
private pattern mayInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mayInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mayInstanceOfExpression_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variRef);
}
private pattern currentInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
// Must, May and Current queries for pattern validation hasNoReference
private pattern mustInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mayInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern mayInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mustInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern currentInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find currentInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
// Must, May and Current queries for pattern validation wellLookingPattern
private pattern mustInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
private pattern mayInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_patternElement);
}
private pattern currentInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
// Must, May and Current queries for pattern validation wellLookingPatternElement
private pattern mustInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
private pattern mayInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodePattern);
}
private pattern currentInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
// Must, May and Current queries for pattern validation notWellLookingPatter
private pattern mustInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mayInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mustInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find currentInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
// Must, May and Current queries for pattern validation notWellLookingPatternElement
private pattern mustInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mayInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mustInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find currentInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
// Must, May and Current queries for pattern validation patternElementHasVar
private pattern mustInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
private pattern mayInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variable);
}
private pattern currentInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
// Must, May and Current queries for pattern validation patternElementHasPart
private pattern mustInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
private pattern mayInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_part);
}
private pattern currentInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
// Must, May and Current queries for pattern validation pe
private pattern mustInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern mayInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern currentInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
// Must, May and Current queries for pattern validation notPatternElement
private pattern mustInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mayInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern mayInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mustInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern currentInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find currentInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
// Must, May and Current queries for pattern validation notWellLookingMapliteral
private pattern mustInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}
private pattern mayInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodeLabel);
}
private pattern currentInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationchain_reference_PatternElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find mustInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find mustInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find mustInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern invalidatedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find mustInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern invalidatedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find mustInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern invalidatedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find mustInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern invalidatedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find mustInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_readingClauses_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_return_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_pattern_reference_Match(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_patterns_reference_Pattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpatterns_reference_Pattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_nodepattern_reference_PatternElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_properties_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variable_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_entries_reference_MapLiteral(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationentries_reference_MapLiteral(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_value_reference_MapLiteralEntry(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_body_reference_Return(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_returnItems_reference_ReturnBody(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_items_reference_ReturnItems(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationitems_reference_ReturnItems(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_expression_reference_ReturnItem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variableRef_reference_VariableRef(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustInstanceOfVariableRef_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_nodePattern_reference_PatternElementChain(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodePattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_relationshipPattern_reference_PatternElementChain(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"relationshipPattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_detail_reference_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"detail reference RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_incoming_attribute_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_outgoing_attribute_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find currentInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find currentInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find currentInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern unfinishedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find currentInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern unfinishedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find currentInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern unfinishedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find currentInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern unfinishedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find currentInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipTypes_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipTypes class UndefinedPart");
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodePattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodePattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class UndefinedPart");
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart_by_nodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodeLabels reference NodeLabels");
	find mustInstanceOfNodeLabels_class(problem,interpretation,container);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart_by_detail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"detail reference RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,container);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationdetail_reference_RelationshipPattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class UndefinedPart");
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart_by_chain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"chain reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationchain_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart_by_relationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"relationshipPattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_StringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
pattern refineRelation_incoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_outgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class".
 */
private pattern mustInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class");
}

/**
 * An element may be an instance of type "NodeLabel class".
 */
private pattern mayInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class".
 */
private pattern mustInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class");
}

/**
 * An element may be an instance of type "PatternElementChain class".
 */
private pattern mayInstanceOfPatternElementChain_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class".
 */
private pattern mustInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class");
}

/**
 * An element may be an instance of type "RelationshipPattern class".
 */
private pattern mayInstanceOfRelationshipPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class".
 */
private pattern mustInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class");
}

/**
 * An element may be an instance of type "RelationshipDetail class".
 */
private pattern mayInstanceOfRelationshipDetail_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class".
 */
private pattern mustInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class");
}

/**
 * An element may be an instance of type "RelationshipTypes class".
 */
private pattern mayInstanceOfRelationshipTypes_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class DefinedPart".
 */
private pattern mustInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class DefinedPart");
}

/**
 * An element may be an instance of type "Match class DefinedPart".
 */
private pattern mayInstanceOfMatch_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class UndefinedPart".
 */
private pattern mustInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class UndefinedPart");
}

/**
 * An element may be an instance of type "Match class UndefinedPart".
 */
private pattern mayInstanceOfMatch_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class DefinedPart".
 */
private pattern mustInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class DefinedPart");
}

/**
 * An element may be an instance of type "Pattern class DefinedPart".
 */
private pattern mayInstanceOfPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class UndefinedPart".
 */
private pattern mustInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class UndefinedPart");
}

/**
 * An element may be an instance of type "Pattern class UndefinedPart".
 */
private pattern mayInstanceOfPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class DefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class DefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mustInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternPart class UndefinedPart".
 */
private pattern mayInstanceOfPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class DefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class DefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mustInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElement class UndefinedPart".
 */
private pattern mayInstanceOfPatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class DefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class DefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class DefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mustInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class UndefinedPart");
}

/**
 * An element may be an instance of type "NodePattern class UndefinedPart".
 */
private pattern mayInstanceOfNodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class DefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class DefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mustInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableDeclaration class UndefinedPart".
 */
private pattern mayInstanceOfVariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class DefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteral class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class DefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class DefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class UndefinedPart");
}

/**
 * An element may be an instance of type "MapLiteralEntry class UndefinedPart".
 */
private pattern mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class DefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class DefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mustInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class UndefinedPart");
}

/**
 * An element may be an instance of type "StringLiteral class UndefinedPart".
 */
private pattern mayInstanceOfStringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class DefinedPart".
 */
private pattern mustInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class DefinedPart");
}

/**
 * An element may be an instance of type "Return class DefinedPart".
 */
private pattern mayInstanceOfReturn_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class UndefinedPart".
 */
private pattern mustInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class UndefinedPart");
}

/**
 * An element may be an instance of type "Return class UndefinedPart".
 */
private pattern mayInstanceOfReturn_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class DefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mustInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnBody class UndefinedPart".
 */
private pattern mayInstanceOfReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class DefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mustInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItems class UndefinedPart".
 */
private pattern mayInstanceOfReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class DefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class DefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mustInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class UndefinedPart");
}

/**
 * An element may be an instance of type "ReturnItem class UndefinedPart".
 */
private pattern mayInstanceOfReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class DefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class DefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class DefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mustInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class UndefinedPart");
}

/**
 * An element may be an instance of type "VariableRef class UndefinedPart".
 */
private pattern mayInstanceOfVariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class DefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class DefinedPart".
 */
private pattern mustInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class DefinedPart");
}

/**
 * An element may be an instance of type "Query class DefinedPart".
 */
private pattern mayInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class UndefinedPart".
 */
private pattern mustInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class UndefinedPart");
}

/**
 * An element may be an instance of type "Query class UndefinedPart".
 */
private pattern mayInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class DefinedPart".
 */
private pattern mustInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class DefinedPart");
}

/**
 * An element may be an instance of type "Statement class DefinedPart".
 */
private pattern mayInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class UndefinedPart".
 */
private pattern mustInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class UndefinedPart");
}

/**
 * An element may be an instance of type "Statement class UndefinedPart".
 */
private pattern mayInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class DefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class DefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mustInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class UndefinedPart");
}

/**
 * An element may be an instance of type "ReadingClause class UndefinedPart".
 */
private pattern mayInstanceOfReadingClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class DefinedPart".
 */
private pattern mustInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class DefinedPart");
}

/**
 * An element may be an instance of type "Clause class DefinedPart".
 */
private pattern mayInstanceOfClause_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfClause_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class UndefinedPart".
 */
private pattern mustInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class UndefinedPart");
}

/**
 * An element may be an instance of type "Clause class UndefinedPart".
 */
private pattern mayInstanceOfClause_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class DefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class DefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class UndefinedPart");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class UndefinedPart".
 */
private pattern mayInstanceOfAnonymousPatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class DefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabels class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class DefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class DefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mustInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class UndefinedPart");
}

/**
 * An element may be an instance of type "NodeLabel class UndefinedPart".
 */
private pattern mayInstanceOfNodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class DefinedPart".
 */
private pattern mustInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class DefinedPart");
}

/**
 * An element may be an instance of type "Properties class DefinedPart".
 */
private pattern mayInstanceOfProperties_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class UndefinedPart".
 */
private pattern mustInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class UndefinedPart");
}

/**
 * An element may be an instance of type "Properties class UndefinedPart".
 */
private pattern mayInstanceOfProperties_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class DefinedPart".
 */
private pattern mustInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class DefinedPart");
}

/**
 * An element may be an instance of type "Literal class DefinedPart".
 */
private pattern mayInstanceOfLiteral_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class UndefinedPart".
 */
private pattern mustInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class UndefinedPart");
}

/**
 * An element may be an instance of type "Literal class UndefinedPart".
 */
private pattern mayInstanceOfLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class DefinedPart".
 */
private pattern mustInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class DefinedPart");
}

/**
 * An element may be an instance of type "Expression class DefinedPart".
 */
private pattern mayInstanceOfExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class UndefinedPart".
 */
private pattern mustInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class UndefinedPart");
}

/**
 * An element may be an instance of type "Expression class UndefinedPart".
 */
private pattern mayInstanceOfExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class DefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class DefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mustInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class UndefinedPart");
}

/**
 * An element may be an instance of type "PropertyExpression class UndefinedPart".
 */
private pattern mayInstanceOfPropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class DefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class DefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mustInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElementChain class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElementChain class UndefinedPart");
}

/**
 * An element may be an instance of type "PatternElementChain class UndefinedPart".
 */
private pattern mayInstanceOfPatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElementChain_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class DefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipPattern class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipPattern class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipPattern class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipPattern_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class DefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipDetail class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipDetail class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipDetail class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipDetail_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class DefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class DefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mustInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RelationshipTypes class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RelationshipTypes class UndefinedPart");
}

/**
 * An element may be an instance of type "RelationshipTypes class UndefinedPart".
 */
private pattern mayInstanceOfRelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find scopeDisallowsNewRelationshipTypes_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 2);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodeLabels reference NodeLabels(source,target)
 */
private pattern mustInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodeLabels reference NodeLabels");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodeLabels reference NodeLabels(source,target)
 */
private pattern mayInRelationnodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodeLabels_class(problem,interpretation,source);
	find mayInstanceOfNodeLabel_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,_);
	check(numberOfExistingReferences < 2);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodePattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodePattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodePattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationnodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mustInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"relationshipPattern reference PatternElementChain");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>relationshipPattern reference PatternElementChain(source,target)
 */
private pattern mayInRelationrelationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElementChain_class(problem,interpretation,source);
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []detail reference RelationshipPattern(source,target)
 */
private pattern mustInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"detail reference RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>detail reference RelationshipPattern(source,target)
 */
private pattern mayInRelationdetail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference RelationshipDetail(source,target)
 */
private pattern mustInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference RelationshipDetail(source,target)
 */
private pattern mayInRelationvariable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference RelationshipDetail(source,target)
 */
private pattern mustInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference RelationshipDetail(source,target)
 */
private pattern mayInRelationproperties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []chain reference PatternElement(source,target)
 */
private pattern mustInRelationchain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"chain reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>chain reference PatternElement(source,target)
 */
private pattern mayInRelationchain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfPatternElementChain_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationchain_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []incoming attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>incoming attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationincoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []outgoing attribute RelationshipPattern(source,target)
 */
private pattern mustInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>outgoing attribute RelationshipPattern(source,target)
 */
private pattern mayInRelationoutgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipPattern_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute RelationshipDetail(source,target)
 */
private pattern mustInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute RelationshipDetail(source,target)
 */
private pattern mayInRelationoptional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfRelationshipDetail_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////
// Must, May and Current queries for pattern validation hasReference
private pattern mustInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
private pattern mayInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mayInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mayInstanceOfExpression_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variRef);
}
private pattern currentInRelation_pattern_validation_hasReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_retI, var_variRef)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInstanceOfExpression_class(problem,interpretation,var_variRef);
	// retI is exported
	// variRef is exported
	find mustInstanceOfVariableRef_class(problem,interpretation,var_variRef);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_retI);
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,var_retI,var_virtual0);
	find mustInstanceOfExpression_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variRef;
}
// Must, May and Current queries for pattern validation hasNoReference
private pattern mustInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mayInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern mayInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find mustInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
private pattern currentInRelation_pattern_validation_hasNoReference(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,var_ri);
	// ri is exported
	neg find currentInRelation_pattern_validation_hasReference(problem,interpretation,var_ri,_var__0);
}
// Must, May and Current queries for pattern validation wellLookingPattern
private pattern mustInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
private pattern mayInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_patternElement);
}
private pattern currentInRelation_pattern_validation_wellLookingPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern, var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// pattern is exported
	// patternElement is exported
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,var_pattern,var_virtual0);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_patternElement;
}
// Must, May and Current queries for pattern validation wellLookingPatternElement
private pattern mustInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
private pattern mayInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodePattern);
}
private pattern currentInRelation_pattern_validation_wellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_nodePattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_nodePattern);
	// patternElement is exported
	// nodePattern is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfNodePattern_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodePattern;
}
// Must, May and Current queries for pattern validation notWellLookingPatter
private pattern mustInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mayInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find mustInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatter(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,var_pattern);
	// pattern is exported
	neg find currentInRelation_pattern_validation_wellLookingPattern(problem,interpretation,var_pattern,_var__0);
}
// Must, May and Current queries for pattern validation notWellLookingPatternElement
private pattern mustInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mayInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern mayInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find mustInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
private pattern currentInRelation_pattern_validation_notWellLookingPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	// patternElement is exported
	neg find currentInRelation_pattern_validation_wellLookingPatternElement(problem,interpretation,var_patternElement,_var__0);
}
// Must, May and Current queries for pattern validation patternElementHasVar
private pattern mustInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
private pattern mayInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_variable);
}
private pattern currentInRelation_pattern_validation_patternElementHasVar(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_variable);
	// patternElement is exported
	// variable is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationvar_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_variable;
}
// Must, May and Current queries for pattern validation patternElementHasPart
private pattern mustInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
private pattern mayInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_part);
}
private pattern currentInRelation_pattern_validation_patternElementHasPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_part);
	// patternElement is exported
	// part is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_patternElement);
	find mustInRelationpart_reference_PatternPart(problem,interpretation,var_patternElement,var_virtual0);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_part;
}
// Must, May and Current queries for pattern validation pe
private pattern mustInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern mayInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mayInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
private pattern currentInRelation_pattern_validation_pe(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_pe)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
	// pe is exported
	find mustInstanceOfPatternElement_class(problem,interpretation,var_pe);
}
// Must, May and Current queries for pattern validation notPatternElement
private pattern mustInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mayInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern mayInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find mustInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
private pattern currentInRelation_pattern_validation_notPatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,var_patternPart);
	// patternPart is exported
	neg find currentInRelation_pattern_validation_pe(problem,interpretation,var_patternPart);
}
// Must, May and Current queries for pattern validation notWellLookingMapliteral
private pattern mustInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}
private pattern mayInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mayInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mayInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	find mayEquivalent(problem, interpretation, var_virtual0, var_nodeLabel);
}
private pattern currentInRelation_pattern_validation_notWellLookingMapliteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_nodeLabel);
	// mapLiteral is exported
	// nodeLabel is exported
	find mustInstanceOfMapLiteral_class(problem,interpretation,var_mapLiteral);
	find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,var_mapLiteral,var_virtual0);
	find mustInstanceOfNodeLabel_class(problem,interpretation,var_virtual0);
	var_virtual0 == var_nodeLabel;
}

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodeLabels_reference_NodeLabels(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,source,target); }or
	
	{ find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_RelationshipDetail(problem,interpretation,source,target); }or
	
	{ find mustInRelationchain_reference_PatternElement(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////
pattern invalidatedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find mustInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find mustInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern invalidatedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find mustInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern invalidatedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find mustInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern invalidatedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find mustInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern invalidatedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find mustInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern invalidatedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find mustInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////
pattern unfinishedLowerMultiplicity_readingClauses_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_return_reference_SinglePartQuery(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_pattern_reference_Match(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_patterns_reference_Pattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationpatterns_reference_Pattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_nodepattern_reference_PatternElement(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_properties_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variable_reference_NodePattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_entries_reference_MapLiteral(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationentries_reference_MapLiteral(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_value_reference_MapLiteralEntry(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_body_reference_Return(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_returnItems_reference_ReturnBody(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_items_reference_ReturnItems(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationitems_reference_ReturnItems(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_expression_reference_ReturnItem(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_variableRef_reference_VariableRef(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustInstanceOfVariableRef_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_nodePattern_reference_PatternElementChain(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodePattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationnodePattern_reference_PatternElementChain(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_relationshipPattern_reference_PatternElementChain(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"relationshipPattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_detail_reference_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"detail reference RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationdetail_reference_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_incoming_attribute_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}
pattern unfinishedLowerMultiplicity_outgoing_attribute_RelationshipPattern(problem:LogicProblem, interpretation:PartialInterpretation, relationIterpretation:PartialRelationInterpretation, object:DefinedElement,missingMultiplicity) {
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,object);
	numberOfExistingReferences == count find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,object,_);
	check(numberOfExistingReferences < 1);
	missingMultiplicity == eval(1-numberOfExistingReferences);
}

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////
pattern unfinishedBy_pattern_validation_hasNoReference(problem:LogicProblem, interpretation:PartialInterpretation,
	var_ri)
{
	find currentInRelation_pattern_validation_hasNoReference(problem,interpretation,var_ri);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatter(problem:LogicProblem, interpretation:PartialInterpretation,
	var_pattern)
{
	find currentInRelation_pattern_validation_notWellLookingPatter(problem,interpretation,var_pattern);
}
pattern unfinishedBy_pattern_validation_notWellLookingPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement)
{
	find currentInRelation_pattern_validation_notWellLookingPatternElement(problem,interpretation,var_patternElement);
}
pattern unfinishedBy_pattern_validation_patternElementHasVar(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_variable)
{
	find currentInRelation_pattern_validation_patternElementHasVar(problem,interpretation,var_patternElement,var_variable);
}
pattern unfinishedBy_pattern_validation_patternElementHasPart(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternElement, var_part)
{
	find currentInRelation_pattern_validation_patternElementHasPart(problem,interpretation,var_patternElement,var_part);
}
pattern unfinishedBy_pattern_validation_notPatternElement(problem:LogicProblem, interpretation:PartialInterpretation,
	var_patternPart)
{
	find currentInRelation_pattern_validation_notPatternElement(problem,interpretation,var_patternPart);
}
pattern unfinishedBy_pattern_validation_notWellLookingMapliteral(problem:LogicProblem, interpretation:PartialInterpretation,
	var_mapLiteral, var_nodeLabel)
{
	find currentInRelation_pattern_validation_notWellLookingMapliteral(problem,interpretation,var_mapLiteral,var_nodeLabel);
}

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart_by_variable_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvariable_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class UndefinedPart");
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart_by_detail_reference_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"detail reference RelationshipPattern");
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,container);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationdetail_reference_RelationshipPattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipDetail_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipDetail class UndefinedPart");
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class UndefinedPart");
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class UndefinedPart");
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class UndefinedPart");
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart_by_nodeLabels_reference_NodeLabels(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodeLabels reference NodeLabels");
	find mustInstanceOfNodeLabels_class(problem,interpretation,container);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodeLabels_reference_NodeLabels(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class UndefinedPart");
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class UndefinedPart");
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class UndefinedPart");
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class UndefinedPart");
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipTypes_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipTypes class UndefinedPart");
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart_by_relationshipPattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"relationshipPattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationrelationshipPattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RelationshipPattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RelationshipPattern class UndefinedPart");
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class UndefinedPart");
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class UndefinedPart");
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class UndefinedPart");
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart_by_nodePattern_reference_PatternElementChain(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodePattern reference PatternElementChain");
	find mustInstanceOfPatternElementChain_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationnodePattern_reference_PatternElementChain(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class UndefinedPart");
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart_by_properties_reference_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference RelationshipDetail");
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationproperties_reference_RelationshipDetail(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class UndefinedPart");
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class UndefinedPart");
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class UndefinedPart");
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class UndefinedPart");
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart_by_chain_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"chain reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationchain_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElementChain_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElementChain class UndefinedPart");
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class UndefinedPart");
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_VariableDeclaration_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipDetail_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabel_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipTypes_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipDetail_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_RelationshipPattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElementChain_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElementChain_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipTypes_class(problem,interpretation,element);
	neg find mustInstanceOfRelationshipPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
pattern refineRelation_incoming_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"incoming attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationincoming_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_outgoing_attribute_RelationshipPattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"outgoing attribute RelationshipPattern");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipPattern_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
	neg find mustInRelationoutgoing_attribute_RelationshipPattern(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_RelationshipDetail(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute RelationshipDetail");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfRelationshipDetail_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_RelationshipDetail(problem,interpretation,from,to);
}
