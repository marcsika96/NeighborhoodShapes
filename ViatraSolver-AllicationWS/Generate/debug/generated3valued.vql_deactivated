import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute VariableDeclaration(source,target)
 */
private pattern mustInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute VariableDeclaration(source,target)
 */
private pattern mayInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute MapLiteralEntry(source,target)
 */
private pattern mustInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute MapLiteralEntry(source,target)
 */
private pattern mayInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute StringLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute StringLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfStringLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return attribute Return(source,target)
 */
private pattern mustInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return attribute Return(source,target)
 */
private pattern mayInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreturn_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_MapLiteralEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_MapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfStringLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
}
pattern refineRelation_return_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationreturn_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationreturn_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute VariableDeclaration(source,target)
 */
private pattern mustInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute VariableDeclaration(source,target)
 */
private pattern mayInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute MapLiteralEntry(source,target)
 */
private pattern mustInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute MapLiteralEntry(source,target)
 */
private pattern mayInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute StringLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute StringLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfStringLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return attribute Return(source,target)
 */
private pattern mustInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return attribute Return(source,target)
 */
private pattern mayInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreturn_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Clause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Clause class");
	find mayInstanceOfClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class");
	find mayInstanceOfNodeLabels_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class");
	find mayInstanceOfPropertyExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Clause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Literal_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Properties_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Statement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_AnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Expression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_ReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfStringLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
}
pattern refineRelation_return_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationreturn_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationreturn_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute VariableDeclaration(source,target)
 */
private pattern mustInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute VariableDeclaration(source,target)
 */
private pattern mayInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute MapLiteralEntry(source,target)
 */
private pattern mustInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute MapLiteralEntry(source,target)
 */
private pattern mayInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute StringLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute StringLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfStringLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return attribute Return(source,target)
 */
private pattern mustInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return attribute Return(source,target)
 */
private pattern mayInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreturn_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_AnonymousPatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class");
	find mayInstanceOfPropertyExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Clause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Clause class");
	find mayInstanceOfClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class");
	find mayInstanceOfNodeLabels_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_AnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Literal_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Properties_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Clause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Statement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}
pattern refineTypeTo_ReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
}
pattern refineTypeTo_Expression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfStringLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
}
pattern refineRelation_return_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationreturn_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationreturn_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute VariableDeclaration(source,target)
 */
private pattern mustInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute VariableDeclaration(source,target)
 */
private pattern mayInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute MapLiteralEntry(source,target)
 */
private pattern mustInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute MapLiteralEntry(source,target)
 */
private pattern mayInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute StringLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute StringLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfStringLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return attribute Return(source,target)
 */
private pattern mustInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return attribute Return(source,target)
 */
private pattern mayInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreturn_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Expression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class");
	find mayInstanceOfPropertyExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class");
	find mayInstanceOfNodeLabels_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Clause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Clause class");
	find mayInstanceOfClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Expression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Literal_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Clause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Statement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
}
pattern refineTypeTo_Properties_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_AnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_ReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfStringLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
}
pattern refineRelation_return_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationreturn_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationreturn_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute VariableDeclaration(source,target)
 */
private pattern mustInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute VariableDeclaration(source,target)
 */
private pattern mayInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute MapLiteralEntry(source,target)
 */
private pattern mustInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute MapLiteralEntry(source,target)
 */
private pattern mayInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute StringLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute StringLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfStringLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return attribute Return(source,target)
 */
private pattern mustInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return attribute Return(source,target)
 */
private pattern mayInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreturn_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_ReturnBody_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class");
	find mayInstanceOfPropertyExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Clause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Clause class");
	find mayInstanceOfClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class");
	find mayInstanceOfNodeLabels_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_ReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Properties_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Literal_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Statement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Expression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_AnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Clause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_ReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfStringLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
}
pattern refineRelation_return_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationreturn_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationreturn_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []alias reference ReturnItem(source,target)
 */
private pattern mustInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"alias reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>alias reference ReturnItem(source,target)
 */
private pattern mayInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute VariableDeclaration(source,target)
 */
private pattern mustInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute VariableDeclaration(source,target)
 */
private pattern mayInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute MapLiteralEntry(source,target)
 */
private pattern mustInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute MapLiteralEntry(source,target)
 */
private pattern mayInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute StringLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute StringLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfStringLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return attribute Return(source,target)
 */
private pattern mustInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return attribute Return(source,target)
 */
private pattern mayInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreturn_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_RegularQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class");
	find mayInstanceOfNodeLabels_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_alias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"alias reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationalias_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Clause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Clause class");
	find mayInstanceOfClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class");
	find mayInstanceOfPropertyExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_RegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Expression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_ReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_AnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Clause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Statement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Properties_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Literal_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfStringLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
}
pattern refineRelation_return_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationreturn_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationreturn_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []alias reference ReturnItem(source,target)
 */
private pattern mustInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"alias reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>alias reference ReturnItem(source,target)
 */
private pattern mayInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute VariableDeclaration(source,target)
 */
private pattern mustInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute VariableDeclaration(source,target)
 */
private pattern mayInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute MapLiteralEntry(source,target)
 */
private pattern mustInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute MapLiteralEntry(source,target)
 */
private pattern mayInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute StringLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute StringLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfStringLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return attribute Return(source,target)
 */
private pattern mustInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return attribute Return(source,target)
 */
private pattern mayInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreturn_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_PropertyExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class");
	find mayInstanceOfPropertyExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class");
	find mayInstanceOfNodeLabels_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Clause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Clause class");
	find mayInstanceOfClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_alias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"alias reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationalias_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_PropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Expression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Properties_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Clause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_AnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Literal_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_Statement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_ReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfStringLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
}
pattern refineRelation_return_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationreturn_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationreturn_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNumberLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNumberLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNumberLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNumberLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabel class".
 */
private pattern mustInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabel class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabel class");
}

/**
 * An element may be an instance of type "NodeLabel class".
 */
private pattern mayInstanceOfNodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabel_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabel_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNumberLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNumberLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Where class".
 */
private pattern mustInstanceOfWhere_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Where class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewWhere_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Where class");
}

/**
 * An element may be an instance of type "Where class".
 */
private pattern mayInstanceOfWhere_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewWhere_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewWhere_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfWhere_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AndExpression class".
 */
private pattern mustInstanceOfAndExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AndExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAndExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AndExpression class");
}

/**
 * An element may be an instance of type "AndExpression class".
 */
private pattern mayInstanceOfAndExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewAndExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewAndExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAndExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ComparisonExpression class".
 */
private pattern mustInstanceOfComparisonExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ComparisonExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewComparisonExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ComparisonExpression class");
}

/**
 * An element may be an instance of type "ComparisonExpression class".
 */
private pattern mayInstanceOfComparisonExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewComparisonExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewComparisonExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfComparisonExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyLookupExpression class".
 */
private pattern mustInstanceOfPropertyLookupExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyLookupExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyLookupExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyLookupExpression class");
}

/**
 * An element may be an instance of type "PropertyLookupExpression class".
 */
private pattern mayInstanceOfPropertyLookupExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyLookupExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyLookupExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyLookup class".
 */
private pattern mustInstanceOfPropertyLookup_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyLookup class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyLookup_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyLookup class");
}

/**
 * An element may be an instance of type "PropertyLookup class".
 */
private pattern mayInstanceOfPropertyLookup_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyLookup_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyLookup_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyLookup_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NumberLiteral class".
 */
private pattern mustInstanceOfNumberLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NumberLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNumberLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NumberLiteral class");
}

/**
 * An element may be an instance of type "NumberLiteral class".
 */
private pattern mayInstanceOfNumberLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewNumberLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewNumberLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNumberLiteral_class(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []alias reference ReturnItem(source,target)
 */
private pattern mustInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"alias reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>alias reference ReturnItem(source,target)
 */
private pattern mayInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference Where(source,target)
 */
private pattern mustInRelationexpression_reference_Where(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference Where");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference Where(source,target)
 */
private pattern mayInRelationexpression_reference_Where(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfWhere_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_Where(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_Where(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []left reference AndExpression(source,target)
 */
private pattern mustInRelationleft_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"left reference AndExpression");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>left reference AndExpression(source,target)
 */
private pattern mayInRelationleft_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAndExpression_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationleft_reference_AndExpression(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationleft_reference_AndExpression(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []right reference AndExpression(source,target)
 */
private pattern mustInRelationright_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"right reference AndExpression");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>right reference AndExpression(source,target)
 */
private pattern mayInRelationright_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAndExpression_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationright_reference_AndExpression(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationright_reference_AndExpression(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []left reference ComparisonExpression(source,target)
 */
private pattern mustInRelationleft_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"left reference ComparisonExpression");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>left reference ComparisonExpression(source,target)
 */
private pattern mayInRelationleft_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfComparisonExpression_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationleft_reference_ComparisonExpression(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationleft_reference_ComparisonExpression(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []right reference ComparisonExpression(source,target)
 */
private pattern mustInRelationright_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"right reference ComparisonExpression");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>right reference ComparisonExpression(source,target)
 */
private pattern mayInRelationright_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfComparisonExpression_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationright_reference_ComparisonExpression(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationright_reference_ComparisonExpression(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute VariableDeclaration(source,target)
 */
private pattern mustInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute VariableDeclaration(source,target)
 */
private pattern mayInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute MapLiteralEntry(source,target)
 */
private pattern mustInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute MapLiteralEntry(source,target)
 */
private pattern mayInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute StringLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute StringLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfStringLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return attribute Return(source,target)
 */
private pattern mustInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return attribute Return(source,target)
 */
private pattern mayInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreturn_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []labelName attribute NodeLabel(source,target)
 */
private pattern mustInRelationlabelName_attribute_NodeLabel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"labelName attribute NodeLabel");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>labelName attribute NodeLabel(source,target)
 */
private pattern mayInRelationlabelName_attribute_NodeLabel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodeLabel_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationlabelName_attribute_NodeLabel(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationlabelName_attribute_NodeLabel(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []operator attribute AndExpression(source,target)
 */
private pattern mustInRelationoperator_attribute_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"operator attribute AndExpression");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>operator attribute AndExpression(source,target)
 */
private pattern mayInRelationoperator_attribute_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAndExpression_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoperator_attribute_AndExpression(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoperator_attribute_AndExpression(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []operator attribute ComparisonExpression(source,target)
 */
private pattern mustInRelationoperator_attribute_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"operator attribute ComparisonExpression");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>operator attribute ComparisonExpression(source,target)
 */
private pattern mayInRelationoperator_attribute_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfComparisonExpression_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoperator_attribute_ComparisonExpression(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoperator_attribute_ComparisonExpression(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []propertyKeyName attribute PropertyLookup(source,target)
 */
private pattern mustInRelationpropertyKeyName_attribute_PropertyLookup(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"propertyKeyName attribute PropertyLookup");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>propertyKeyName attribute PropertyLookup(source,target)
 */
private pattern mayInRelationpropertyKeyName_attribute_PropertyLookup(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPropertyLookup_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpropertyKeyName_attribute_PropertyLookup(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationpropertyKeyName_attribute_PropertyLookup(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []propertyOperator attribute PropertyLookup(source,target)
 */
private pattern mustInRelationpropertyOperator_attribute_PropertyLookup(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"propertyOperator attribute PropertyLookup");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>propertyOperator attribute PropertyLookup(source,target)
 */
private pattern mayInRelationpropertyOperator_attribute_PropertyLookup(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPropertyLookup_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpropertyOperator_attribute_PropertyLookup(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationpropertyOperator_attribute_PropertyLookup(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute NumberLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_NumberLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute NumberLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute NumberLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_NumberLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNumberLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_NumberLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_NumberLiteral(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_Where(problem,interpretation,source,target); }or
	
	{ find mustInRelationleft_reference_AndExpression(problem,interpretation,source,target); }or
	
	{ find mustInRelationright_reference_AndExpression(problem,interpretation,source,target); }or
	
	{ find mustInRelationleft_reference_ComparisonExpression(problem,interpretation,source,target); }or
	
	{ find mustInRelationright_reference_ComparisonExpression(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAndExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyLookup_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabel_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfComparisonExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfWhere_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNumberLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_PropertyExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class");
	find mayInstanceOfPropertyExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_expression_reference_Where(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference Where");
	find mustInstanceOfWhere_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_Where(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_left_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_right_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationright_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_left_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_right_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationright_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabel_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabel class");
	find mayInstanceOfNodeLabel_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class");
	find mayInstanceOfNodeLabels_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Where_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Where class");
	find mayInstanceOfWhere_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_expression_reference_Where(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference Where");
	find mustInstanceOfWhere_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_Where(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_left_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_right_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationright_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_left_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_right_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationright_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_expression_reference_Where(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference Where");
	find mustInstanceOfWhere_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_Where(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_left_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_right_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationright_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_left_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_right_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationright_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_expression_reference_Where(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference Where");
	find mustInstanceOfWhere_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_Where(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_left_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_right_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationright_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_left_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_right_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationright_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyLookupExpression_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyLookupExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfPropertyLookupExpression_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyLookupExpression_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyLookupExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfPropertyLookupExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyLookupExpression_class_by_expression_reference_Where(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyLookupExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference Where");
	find mustInstanceOfWhere_class(problem,interpretation,container);
	find mayInstanceOfPropertyLookupExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_Where(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyLookupExpression_class_by_left_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyLookupExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfPropertyLookupExpression_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyLookupExpression_class_by_right_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyLookupExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfPropertyLookupExpression_class(problem,interpretation,newObject);
	find mayInRelationright_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyLookupExpression_class_by_left_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyLookupExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfPropertyLookupExpression_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyLookupExpression_class_by_right_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyLookupExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfPropertyLookupExpression_class(problem,interpretation,newObject);
	find mayInRelationright_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyLookupExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyLookupExpression class");
	find mayInstanceOfPropertyLookupExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_expression_reference_Where(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference Where");
	find mustInstanceOfWhere_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_Where(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_left_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_right_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationright_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_left_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_right_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationright_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AndExpression_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AndExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfAndExpression_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AndExpression_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AndExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfAndExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AndExpression_class_by_expression_reference_Where(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AndExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference Where");
	find mustInstanceOfWhere_class(problem,interpretation,container);
	find mayInstanceOfAndExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_Where(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AndExpression_class_by_left_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AndExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfAndExpression_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AndExpression_class_by_right_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AndExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfAndExpression_class(problem,interpretation,newObject);
	find mayInRelationright_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AndExpression_class_by_left_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AndExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfAndExpression_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AndExpression_class_by_right_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AndExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfAndExpression_class(problem,interpretation,newObject);
	find mayInRelationright_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AndExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AndExpression class");
	find mayInstanceOfAndExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_alias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"alias reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationalias_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyLookup_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyLookup class");
	find mayInstanceOfPropertyLookup_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NumberLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NumberLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfNumberLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NumberLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NumberLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfNumberLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NumberLiteral_class_by_expression_reference_Where(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NumberLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference Where");
	find mustInstanceOfWhere_class(problem,interpretation,container);
	find mayInstanceOfNumberLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_Where(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NumberLiteral_class_by_left_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NumberLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfNumberLiteral_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NumberLiteral_class_by_right_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NumberLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfNumberLiteral_class(problem,interpretation,newObject);
	find mayInRelationright_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NumberLiteral_class_by_left_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NumberLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfNumberLiteral_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NumberLiteral_class_by_right_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NumberLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfNumberLiteral_class(problem,interpretation,newObject);
	find mayInRelationright_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NumberLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NumberLiteral class");
	find mayInstanceOfNumberLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Clause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Clause class");
	find mayInstanceOfClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ComparisonExpression_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ComparisonExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfComparisonExpression_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ComparisonExpression_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ComparisonExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfComparisonExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ComparisonExpression_class_by_expression_reference_Where(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ComparisonExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference Where");
	find mustInstanceOfWhere_class(problem,interpretation,container);
	find mayInstanceOfComparisonExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_Where(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ComparisonExpression_class_by_left_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ComparisonExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfComparisonExpression_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ComparisonExpression_class_by_right_reference_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ComparisonExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference AndExpression");
	find mustInstanceOfAndExpression_class(problem,interpretation,container);
	find mayInstanceOfComparisonExpression_class(problem,interpretation,newObject);
	find mayInRelationright_reference_AndExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ComparisonExpression_class_by_left_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ComparisonExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"left reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfComparisonExpression_class(problem,interpretation,newObject);
	find mayInRelationleft_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ComparisonExpression_class_by_right_reference_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ComparisonExpression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"right reference ComparisonExpression");
	find mustInstanceOfComparisonExpression_class(problem,interpretation,container);
	find mayInstanceOfComparisonExpression_class(problem,interpretation,newObject);
	find mayInRelationright_reference_ComparisonExpression(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ComparisonExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ComparisonExpression class");
	find mayInstanceOfComparisonExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_PropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNumberLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabel_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_ReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_Where_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_Expression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfNumberLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_Literal_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNumberLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Properties_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyLookupExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_AnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
}
pattern refineTypeTo_AndExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyLookup_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_NumberLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNumberLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNumberLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
}
pattern refineTypeTo_Statement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_Clause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
}
pattern refineTypeTo_ComparisonExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfComparisonExpression_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookupExpression_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfAndExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyLookup_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabel_class(problem,interpretation,element);
	neg find mustInstanceOfWhere_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfComparisonExpression_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfStringLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
}
pattern refineRelation_return_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationreturn_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationreturn_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
pattern refineRelation_labelName_attribute_NodeLabel(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"labelName attribute NodeLabel");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfNodeLabel_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationlabelName_attribute_NodeLabel(problem,interpretation,from,to);
	neg find mustInRelationlabelName_attribute_NodeLabel(problem,interpretation,from,to);
}
pattern refineRelation_operator_attribute_AndExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"operator attribute AndExpression");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAndExpression_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationoperator_attribute_AndExpression(problem,interpretation,from,to);
	neg find mustInRelationoperator_attribute_AndExpression(problem,interpretation,from,to);
}
pattern refineRelation_operator_attribute_ComparisonExpression(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"operator attribute ComparisonExpression");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfComparisonExpression_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationoperator_attribute_ComparisonExpression(problem,interpretation,from,to);
	neg find mustInRelationoperator_attribute_ComparisonExpression(problem,interpretation,from,to);
}
pattern refineRelation_propertyKeyName_attribute_PropertyLookup(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"propertyKeyName attribute PropertyLookup");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPropertyLookup_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationpropertyKeyName_attribute_PropertyLookup(problem,interpretation,from,to);
	neg find mustInRelationpropertyKeyName_attribute_PropertyLookup(problem,interpretation,from,to);
}
pattern refineRelation_propertyOperator_attribute_PropertyLookup(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"propertyOperator attribute PropertyLookup");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfPropertyLookup_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationpropertyOperator_attribute_PropertyLookup(problem,interpretation,from,to);
	neg find mustInRelationpropertyOperator_attribute_PropertyLookup(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_NumberLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute NumberLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfNumberLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_NumberLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_NumberLiteral(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []alias reference ReturnItem(source,target)
 */
private pattern mustInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"alias reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>alias reference ReturnItem(source,target)
 */
private pattern mayInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute VariableDeclaration(source,target)
 */
private pattern mustInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute VariableDeclaration(source,target)
 */
private pattern mayInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute MapLiteralEntry(source,target)
 */
private pattern mustInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute MapLiteralEntry(source,target)
 */
private pattern mayInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute StringLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute StringLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfStringLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return attribute Return(source,target)
 */
private pattern mustInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return attribute Return(source,target)
 */
private pattern mayInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreturn_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_MapLiteralEntry_class_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class");
	find mayInstanceOfNodeLabels_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Clause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Clause class");
	find mayInstanceOfClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_alias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"alias reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationalias_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class");
	find mayInstanceOfPropertyExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_MapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Expression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_ReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_AnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Properties_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Literal_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Clause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Statement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfStringLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
}
pattern refineRelation_return_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationreturn_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationreturn_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []alias reference ReturnItem(source,target)
 */
private pattern mustInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"alias reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>alias reference ReturnItem(source,target)
 */
private pattern mayInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute VariableDeclaration(source,target)
 */
private pattern mustInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute VariableDeclaration(source,target)
 */
private pattern mayInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute MapLiteralEntry(source,target)
 */
private pattern mustInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute MapLiteralEntry(source,target)
 */
private pattern mayInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute StringLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute StringLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfStringLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return attribute Return(source,target)
 */
private pattern mustInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return attribute Return(source,target)
 */
private pattern mayInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreturn_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Statement_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Clause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Clause class");
	find mayInstanceOfClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_alias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"alias reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationalias_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class");
	find mayInstanceOfPropertyExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class");
	find mayInstanceOfNodeLabels_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Statement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
}
pattern refineTypeTo_Clause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_Literal_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_Properties_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_Expression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_ReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_AnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfStringLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
}
pattern refineRelation_return_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationreturn_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationreturn_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []alias reference ReturnItem(source,target)
 */
private pattern mustInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"alias reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>alias reference ReturnItem(source,target)
 */
private pattern mayInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute VariableDeclaration(source,target)
 */
private pattern mustInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute VariableDeclaration(source,target)
 */
private pattern mayInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute MapLiteralEntry(source,target)
 */
private pattern mustInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute MapLiteralEntry(source,target)
 */
private pattern mayInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute StringLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute StringLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfStringLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return attribute Return(source,target)
 */
private pattern mustInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return attribute Return(source,target)
 */
private pattern mayInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreturn_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_SingleQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class");
	find mayInstanceOfSingleQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class");
	find mayInstanceOfStatement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class");
	find mayInstanceOfQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_alias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"alias reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationalias_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class");
	find mayInstanceOfPropertyExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Clause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Clause class");
	find mayInstanceOfClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class");
	find mayInstanceOfNodeLabels_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class");
	find mayInstanceOfRegularQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class");
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_SingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_Statement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_Clause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_Literal_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}
pattern refineTypeTo_AnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_Expression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_ReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}
pattern refineTypeTo_Properties_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfStringLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
}
pattern refineRelation_return_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationreturn_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationreturn_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
import epackage "http://www.bme.hu/mit/inf/dslreasoner/viatrasolver/partialinterpretationlanguage"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/problem"
import epackage "http://www.bme.hu/mit/inf/dslreasoner/logic/model/language"

//////////
// 0. Util
//////////
private pattern interpretation(problem:LogicProblem, interpretation:PartialInterpretation) {
	PartialInterpretation.problem(interpretation,problem);
}
	
/////////////////////////
// 0.1 Existence
/////////////////////////
private pattern mustExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	find interpretation(problem,interpretation);
	LogicProblem.elements(problem,element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
}

private pattern mayExist(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
    find mustExist(problem,interpretation,element);
} or {
    find interpretation(problem,interpretation);
    neg find elementCloseWorld(element);
    PartialInterpretation.openWorldElements(interpretation,element);
}

private pattern elementCloseWorld(element:DefinedElement) {
	PartialInterpretation.openWorldElements(i,element);
    PartialInterpretation.maxNewElements(i,0);
} or {
	Scope.targetTypeInterpretation(scope,interpretation);
	PartialTypeInterpratation.elements(interpretation,element);
	Scope.maxNewElements(scope,0);
}

////////////////////////
// 0.2 Equivalence
////////////////////////
pattern mayEquivalent(problem:LogicProblem, interpretation:PartialInterpretation, a: DefinedElement, b: DefinedElement) {
	find mayExist(problem,interpretation,a);
	find mayExist(problem,interpretation,b);
	a == b;
}

////////////////////////
// 0.3 Required Patterns by TypeIndexer
////////////////////////
private pattern typeInterpretation(problem:LogicProblem, interpretation:PartialInterpretation, type:TypeDeclaration, typeInterpretation:PartialComplexTypeInterpretation) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
}

private pattern directInstanceOf(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement, type:Type) {
	find interpretation(problem,interpretation);
	LogicProblem.types(problem,type);
	TypeDefinition.elements(type,element);
} or {
	find interpretation(problem,interpretation);
	find typeInterpretation(problem,interpretation,type,typeInterpretation);
	PartialComplexTypeInterpretation.elements(typeInterpretation,element);
}

private pattern isPrimitive(element: PrimitiveElement) {
	PrimitiveElement(element);
}

//////////
// 1. Problem-Specific Base Indexers
//////////
// 1.1 Type Indexers
//////////
// 1.1.1 primitive Type Indexers
//////////

//////////
// 1.1.2 domain-specific Type Indexers
//////////
/**
 * An element must be an instance of type "Cypher class".
 */
private pattern mustInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Cypher class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewCypher_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Cypher class");
}

/**
 * An element may be an instance of type "Cypher class".
 */
private pattern mayInstanceOfCypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewCypher_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfCypher_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AllOptions class".
 */
private pattern mustInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AllOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AllOptions class");
}

/**
 * An element may be an instance of type "AllOptions class".
 */
private pattern mayInstanceOfAllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewAllOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAllOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class".
 */
private pattern mustInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class");
}

/**
 * An element may be an instance of type "SinglePartQuery class".
 */
private pattern mayInstanceOfSinglePartQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Match class".
 */
private pattern mustInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Match class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMatch_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Match class");
}

/**
 * An element may be an instance of type "Match class".
 */
private pattern mayInstanceOfMatch_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMatch_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMatch_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Pattern class".
 */
private pattern mustInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Pattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Pattern class");
}

/**
 * An element may be an instance of type "Pattern class".
 */
private pattern mayInstanceOfPattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternPart class".
 */
private pattern mustInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternPart class");
}

/**
 * An element may be an instance of type "PatternPart class".
 */
private pattern mayInstanceOfPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PatternElement class".
 */
private pattern mustInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PatternElement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PatternElement class");
}

/**
 * An element may be an instance of type "PatternElement class".
 */
private pattern mayInstanceOfPatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPatternElement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPatternElement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodePattern class".
 */
private pattern mustInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodePattern class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodePattern class");
}

/**
 * An element may be an instance of type "NodePattern class".
 */
private pattern mayInstanceOfNodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodePattern_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodePattern_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableDeclaration class".
 */
private pattern mustInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableDeclaration class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableDeclaration class");
}

/**
 * An element may be an instance of type "VariableDeclaration class".
 */
private pattern mayInstanceOfVariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableDeclaration_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableDeclaration_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteral class".
 */
private pattern mustInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteral class");
}

/**
 * An element may be an instance of type "MapLiteral class".
 */
private pattern mayInstanceOfMapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "MapLiteralEntry class".
 */
private pattern mustInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"MapLiteralEntry class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"MapLiteralEntry class");
}

/**
 * An element may be an instance of type "MapLiteralEntry class".
 */
private pattern mayInstanceOfMapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewMapLiteralEntry_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "StringLiteral class".
 */
private pattern mustInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"StringLiteral class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"StringLiteral class");
}

/**
 * An element may be an instance of type "StringLiteral class".
 */
private pattern mayInstanceOfStringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStringLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStringLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Return class".
 */
private pattern mustInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Return class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturn_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Return class");
}

/**
 * An element may be an instance of type "Return class".
 */
private pattern mayInstanceOfReturn_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturn_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturn_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnBody class".
 */
private pattern mustInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnBody class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnBody class");
}

/**
 * An element may be an instance of type "ReturnBody class".
 */
private pattern mayInstanceOfReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnBody_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnBody_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItems class".
 */
private pattern mustInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItems class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItems class");
}

/**
 * An element may be an instance of type "ReturnItems class".
 */
private pattern mayInstanceOfReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItems_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItems_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReturnItem class".
 */
private pattern mustInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReturnItem class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReturnItem class");
}

/**
 * An element may be an instance of type "ReturnItem class".
 */
private pattern mayInstanceOfReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find scopeDisallowsNewReturnItem_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReturnItem_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "VariableRef class".
 */
private pattern mustInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"VariableRef class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"VariableRef class");
}

/**
 * An element may be an instance of type "VariableRef class".
 */
private pattern mayInstanceOfVariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewVariableRef_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfVariableRef_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class".
 */
private pattern mustInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class");
}

/**
 * An element may be an instance of type "SingleQuery class".
 */
private pattern mayInstanceOfSingleQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class".
 */
private pattern mustInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class");
}

/**
 * An element may be an instance of type "RegularQuery class".
 */
private pattern mayInstanceOfRegularQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class".
 */
private pattern mustInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class");
}

/**
 * An element may be an instance of type "Query class".
 */
private pattern mayInstanceOfQuery_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class".
 */
private pattern mustInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class");
}

/**
 * An element may be an instance of type "Statement class".
 */
private pattern mayInstanceOfStatement_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "ReadingClause class".
 */
private pattern mustInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"ReadingClause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"ReadingClause class");
}

/**
 * An element may be an instance of type "ReadingClause class".
 */
private pattern mayInstanceOfReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewReadingClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfReadingClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Clause class".
 */
private pattern mustInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Clause class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewClause_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Clause class");
}

/**
 * An element may be an instance of type "Clause class".
 */
private pattern mayInstanceOfClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewClause_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfClause_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "AnonymousPatternPart class".
 */
private pattern mustInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"AnonymousPatternPart class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"AnonymousPatternPart class");
}

/**
 * An element may be an instance of type "AnonymousPatternPart class".
 */
private pattern mayInstanceOfAnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewAnonymousPatternPart_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "NodeLabels class".
 */
private pattern mustInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"NodeLabels class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"NodeLabels class");
}

/**
 * An element may be an instance of type "NodeLabels class".
 */
private pattern mayInstanceOfNodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewNodeLabels_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfNodeLabels_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Properties class".
 */
private pattern mustInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Properties class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewProperties_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Properties class");
}

/**
 * An element may be an instance of type "Properties class".
 */
private pattern mayInstanceOfProperties_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewProperties_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfProperties_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Literal class".
 */
private pattern mustInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Literal class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Literal class");
}

/**
 * An element may be an instance of type "Literal class".
 */
private pattern mayInstanceOfLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewLiteral_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfLiteral_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "Expression class".
 */
private pattern mustInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Expression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Expression class");
}

/**
 * An element may be an instance of type "Expression class".
 */
private pattern mayInstanceOfExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "PropertyExpression class".
 */
private pattern mustInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"PropertyExpression class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"PropertyExpression class");
}

/**
 * An element may be an instance of type "PropertyExpression class".
 */
private pattern mayInstanceOfPropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewPropertyExpression_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfPropertyExpression_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "QueryOptions class".
 */
private pattern mustInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"QueryOptions class");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"QueryOptions class");
}

/**
 * An element may be an instance of type "QueryOptions class".
 */
private pattern mayInstanceOfQueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewQueryOptions_class(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQueryOptions_class(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class DefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mustInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SinglePartQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SinglePartQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SinglePartQuery class UndefinedPart".
 */
private pattern mayInstanceOfSinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSinglePartQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class DefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class DefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mustInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"SingleQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"SingleQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "SingleQuery class UndefinedPart".
 */
private pattern mayInstanceOfSingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewSingleQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class DefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class DefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mustInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"RegularQuery class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"RegularQuery class UndefinedPart");
}

/**
 * An element may be an instance of type "RegularQuery class UndefinedPart".
 */
private pattern mayInstanceOfRegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
	neg find scopeDisallowsNewRegularQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class DefinedPart".
 */
private pattern mustInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class DefinedPart");
}

/**
 * An element may be an instance of type "Query class DefinedPart".
 */
private pattern mayInstanceOfQuery_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Query class UndefinedPart".
 */
private pattern mustInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Query class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Query class UndefinedPart");
}

/**
 * An element may be an instance of type "Query class UndefinedPart".
 */
private pattern mayInstanceOfQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewQuery_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class DefinedPart".
 */
private pattern mustInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class DefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class DefinedPart");
}

/**
 * An element may be an instance of type "Statement class DefinedPart".
 */
private pattern mayInstanceOfStatement_class_DefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{ find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,element); }
/**
 * An element must be an instance of type "Statement class UndefinedPart".
 */
private pattern mustInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement) {
	Type.name(type,"Statement class UndefinedPart");
	find directInstanceOf(problem,interpretation,element,type);
}
private pattern scopeDisallowsNewStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation) {
	find interpretation(problem,interpretation);
	PartialInterpretation.scopes(interpretation,scope);
	Scope.targetTypeInterpretation(scope,typeInterpretation);
	Scope.maxNewElements(scope,0);
	PartialComplexTypeInterpretation.interpretationOf(typeInterpretation,type);
	Type.name(type,"Statement class UndefinedPart");
}

/**
 * An element may be an instance of type "Statement class UndefinedPart".
 */
private pattern mayInstanceOfStatement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or {
	find interpretation(problem,interpretation);
	PartialInterpretation.openWorldElements(interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find scopeDisallowsNewStatement_class_UndefinedPart(problem, interpretation);
	neg find isPrimitive(element);
} or
{ find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element); }

//////////
// 1.2 Relation Declaration Indexers
//////////
/**
 * Matcher for detecting tuples t where []statement reference Cypher(source,target)
 */
private pattern mustInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"statement reference Cypher");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>statement reference Cypher(source,target)
 */
private pattern mayInRelationstatement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfCypher_class(problem,interpretation,source);
	find mayInstanceOfStatement_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationstatement_reference_Cypher(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []readingClauses reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"readingClauses reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>readingClauses reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreadingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReadingClause_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return reference SinglePartQuery(source,target)
 */
private pattern mustInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return reference SinglePartQuery");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return reference SinglePartQuery(source,target)
 */
private pattern mayInRelationreturn_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfSinglePartQuery_class(problem,interpretation,source);
	find mayInstanceOfReturn_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []pattern reference Match(source,target)
 */
private pattern mustInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"pattern reference Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>pattern reference Match(source,target)
 */
private pattern mayInRelationpattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	find mayInstanceOfPattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpattern_reference_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpattern_reference_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []patterns reference Pattern(source,target)
 */
private pattern mustInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"patterns reference Pattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>patterns reference Pattern(source,target)
 */
private pattern mayInRelationpatterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPattern_class(problem,interpretation,source);
	find mayInstanceOfPatternPart_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []var reference PatternPart(source,target)
 */
private pattern mustInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"var reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>var reference PatternPart(source,target)
 */
private pattern mayInRelationvar_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvar_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []part reference PatternPart(source,target)
 */
private pattern mustInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"part reference PatternPart");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>part reference PatternPart(source,target)
 */
private pattern mayInRelationpart_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternPart_class(problem,interpretation,source);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationpart_reference_PatternPart(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []nodepattern reference PatternElement(source,target)
 */
private pattern mustInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"nodepattern reference PatternElement");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>nodepattern reference PatternElement(source,target)
 */
private pattern mayInRelationnodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfPatternElement_class(problem,interpretation,source);
	find mayInstanceOfNodePattern_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []properties reference NodePattern(source,target)
 */
private pattern mustInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"properties reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>properties reference NodePattern(source,target)
 */
private pattern mayInRelationproperties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfProperties_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variable reference NodePattern(source,target)
 */
private pattern mustInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variable reference NodePattern");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variable reference NodePattern(source,target)
 */
private pattern mayInRelationvariable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfNodePattern_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []entries reference MapLiteral(source,target)
 */
private pattern mustInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"entries reference MapLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>entries reference MapLiteral(source,target)
 */
private pattern mayInRelationentries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteral_class(problem,interpretation,source);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value reference MapLiteralEntry(source,target)
 */
private pattern mustInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value reference MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value reference MapLiteralEntry(source,target)
 */
private pattern mayInRelationvalue_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []body reference Return(source,target)
 */
private pattern mustInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"body reference Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>body reference Return(source,target)
 */
private pattern mayInRelationbody_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	find mayInstanceOfReturnBody_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationbody_reference_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationbody_reference_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []returnItems reference ReturnBody(source,target)
 */
private pattern mustInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"returnItems reference ReturnBody");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>returnItems reference ReturnBody(source,target)
 */
private pattern mayInRelationreturnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnBody_class(problem,interpretation,source);
	find mayInstanceOfReturnItems_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []items reference ReturnItems(source,target)
 */
private pattern mustInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"items reference ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>items reference ReturnItems(source,target)
 */
private pattern mayInRelationitems_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	find mayInstanceOfReturnItem_class(problem,interpretation,target);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []alias reference ReturnItem(source,target)
 */
private pattern mustInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"alias reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>alias reference ReturnItem(source,target)
 */
private pattern mayInRelationalias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []expression reference ReturnItem(source,target)
 */
private pattern mustInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"expression reference ReturnItem");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>expression reference ReturnItem(source,target)
 */
private pattern mayInRelationexpression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItem_class(problem,interpretation,source);
	find mayInstanceOfExpression_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
	// The reference is containment, then a new reference cannot be create if:
	// 1. Multiple parents
	neg find mustContains4(problem,interpretation,_,target);
	// 2. Circle in the containment hierarchy
	neg find mustTransitiveContains(source,target);
} or {
	find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []variableRef reference VariableRef(source,target)
 */
private pattern mustInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>variableRef reference VariableRef(source,target)
 */
private pattern mayInRelationvariableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableRef_class(problem,interpretation,source);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []explain attribute AllOptions(source,target)
 */
private pattern mustInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>explain attribute AllOptions(source,target)
 */
private pattern mayInRelationexplain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationexplain_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []profile attribute AllOptions(source,target)
 */
private pattern mustInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>profile attribute AllOptions(source,target)
 */
private pattern mayInRelationprofile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfAllOptions_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationprofile_attribute_AllOptions(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []optional attribute Match(source,target)
 */
private pattern mustInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>optional attribute Match(source,target)
 */
private pattern mayInRelationoptional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMatch_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationoptional_attribute_Match(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationoptional_attribute_Match(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []name attribute VariableDeclaration(source,target)
 */
private pattern mustInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>name attribute VariableDeclaration(source,target)
 */
private pattern mayInRelationname_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []key attribute MapLiteralEntry(source,target)
 */
private pattern mustInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>key attribute MapLiteralEntry(source,target)
 */
private pattern mayInRelationkey_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []value attribute StringLiteral(source,target)
 */
private pattern mustInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>value attribute StringLiteral(source,target)
 */
private pattern mayInRelationvalue_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfStringLiteral_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []return attribute Return(source,target)
 */
private pattern mustInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>return attribute Return(source,target)
 */
private pattern mayInRelationreturn_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationreturn_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationreturn_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []distinct attribute Return(source,target)
 */
private pattern mustInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>distinct attribute Return(source,target)
 */
private pattern mayInRelationdistinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturn_class(problem,interpretation,source);
	BooleanElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationdistinct_attribute_Return(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationdistinct_attribute_Return(problem,interpretation,source,target);
}
/**
 * Matcher for detecting tuples t where []all attribute ReturnItems(source,target)
 */
private pattern mustInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	PartialRelationInterpretation.relationlinks(relationIterpretation,link);
	BinaryElementRelationLink.param1(link,source);
	BinaryElementRelationLink.param2(link,target);
}
/**
 * Matcher for detecting tuples t where <>all attribute ReturnItems(source,target)
 */
private pattern mayInRelationall_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target:DefinedElement)
{
	find interpretation(problem,interpretation);
	// The two endpoint of the link have to exist
	find mayExist(problem, interpretation, source);
	find mayExist(problem, interpretation, target);
	// Type consistency
	find mayInstanceOfReturnItems_class(problem,interpretation,source);
	StringElement(target);
	// There are "numberOfExistingReferences" currently existing instances of the reference from the source,
	// the upper bound of the multiplicity should be considered.
	numberOfExistingReferences == count find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,_);
	check(numberOfExistingReferences < 1);
} or {
	find mustInRelationall_attribute_ReturnItems(problem,interpretation,source,target);
}

//////////
// 1.3 Relation Definition Indexers
//////////

//////////
// 1.4 Containment Indexer
//////////
private pattern mustContains2(source: DefinedElement, target: DefinedElement) {
	find mustContains4(_,_,source,target);
}
	
private pattern mustContains4(problem:LogicProblem, interpretation:PartialInterpretation,
	source: DefinedElement, target: DefinedElement)
	{ find mustInRelationstatement_reference_Cypher(problem,interpretation,source,target); }or
	
	{ find mustInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturn_reference_SinglePartQuery(problem,interpretation,source,target); }or
	
	{ find mustInRelationpattern_reference_Match(problem,interpretation,source,target); }or
	
	{ find mustInRelationpatterns_reference_Pattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvar_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationpart_reference_PatternPart(problem,interpretation,source,target); }or
	
	{ find mustInRelationnodepattern_reference_PatternElement(problem,interpretation,source,target); }or
	
	{ find mustInRelationproperties_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationvariable_reference_NodePattern(problem,interpretation,source,target); }or
	
	{ find mustInRelationentries_reference_MapLiteral(problem,interpretation,source,target); }or
	
	{ find mustInRelationvalue_reference_MapLiteralEntry(problem,interpretation,source,target); }or
	
	{ find mustInRelationbody_reference_Return(problem,interpretation,source,target); }or
	
	{ find mustInRelationreturnItems_reference_ReturnBody(problem,interpretation,source,target); }or
	
	{ find mustInRelationitems_reference_ReturnItems(problem,interpretation,source,target); }or
	
	{ find mustInRelationalias_reference_ReturnItem(problem,interpretation,source,target); }or
	
	{ find mustInRelationexpression_reference_ReturnItem(problem,interpretation,source,target); }

private pattern mustTransitiveContains(source,target) {
	find mustContains2+(source,target);
}

//////////
// 2. Invalidation Indexers
//////////
// 2.1 Invalidated by WF Queries
//////////

//////////
// 3. Unfinishedness Indexers
//////////
// 3.1 Unfinishedness Measured by Multiplicity
//////////

//////////
// 3.2 Unfinishedness Measured by WF Queries
//////////

//////////
// 4. Refinement Indexers
//////////
// 4.1 Object constructors
//////////
private pattern hasElementInContainment(problem:LogicProblem, interpretation:PartialInterpretation)
{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternElement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodePattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMatch_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPropertyExpression_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfProperties_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAllOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfCypher_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfNodeLabels_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfPattern_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfVariableRef_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItem_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStringLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQueryOptions_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnItems_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfMapLiteral_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturnBody_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReturn_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfReadingClause_class(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_DefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}or{
	find interpretation(problem,interpretation);
	find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,root);
	find mustExist(problem, interpretation, root);
}
pattern createObject_Cypher_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Cypher class");
	find mayInstanceOfCypher_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Query_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Query class UndefinedPart");
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PropertyExpression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PropertyExpression class");
	find mayInstanceOfPropertyExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class_by_body_reference_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"body reference Return");
	find mustInstanceOfReturn_class(problem,interpretation,container);
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayInRelationbody_reference_Return(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnBody_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnBody class");
	find mayInstanceOfReturnBody_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReadingClause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReadingClause class");
	find mayInstanceOfReadingClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableRef_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableRef class");
	find mayInstanceOfVariableRef_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_QueryOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"QueryOptions class");
	find mayInstanceOfQueryOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class_by_nodepattern_reference_PatternElement(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"nodepattern reference PatternElement");
	find mustInstanceOfPatternElement_class(problem,interpretation,container);
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayInRelationnodepattern_reference_PatternElement(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodePattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodePattern class");
	find mayInstanceOfNodePattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_NodeLabels_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"NodeLabels class");
	find mayInstanceOfNodeLabels_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Clause_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Clause class");
	find mayInstanceOfClause_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Literal_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Literal class");
	find mayInstanceOfLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_RegularQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"RegularQuery class UndefinedPart");
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class_by_items_reference_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"items reference ReturnItems");
	find mustInstanceOfReturnItems_class(problem,interpretation,container);
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayInRelationitems_reference_ReturnItems(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItem_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItem class");
	find mayInstanceOfReturnItem_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SingleQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SingleQuery class UndefinedPart");
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteral class");
	find mayInstanceOfMapLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class_by_entries_reference_MapLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"entries reference MapLiteral");
	find mustInstanceOfMapLiteral_class(problem,interpretation,container);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayInRelationentries_reference_MapLiteral(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_MapLiteralEntry_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"MapLiteralEntry class");
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfStatement_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Statement_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Statement class UndefinedPart");
	find mayInstanceOfStatement_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AllOptions_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AllOptions class");
	find mayInstanceOfAllOptions_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_AnonymousPatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"AnonymousPatternPart class");
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Expression_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Expression class");
	find mayInstanceOfExpression_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class_by_return_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"return reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayInRelationreturn_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Return_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Return class");
	find mayInstanceOfReturn_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_var_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"var reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvar_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_variable_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"variable reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationvariable_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class_by_alias_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"alias reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayInRelationalias_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_VariableDeclaration_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"VariableDeclaration class");
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class_by_properties_reference_NodePattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"properties reference NodePattern");
	find mustInstanceOfNodePattern_class(problem,interpretation,container);
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayInRelationproperties_reference_NodePattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Properties_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Properties class");
	find mayInstanceOfProperties_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class_by_readingClauses_reference_SinglePartQuery(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"readingClauses reference SinglePartQuery");
	find mustInstanceOfSinglePartQuery_class(problem,interpretation,container);
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayInRelationreadingClauses_reference_SinglePartQuery(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Match_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Match class");
	find mayInstanceOfMatch_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class_by_part_reference_PatternPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"part reference PatternPart");
	find mustInstanceOfPatternPart_class(problem,interpretation,container);
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayInRelationpart_reference_PatternPart(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternElement_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternElement class");
	find mayInstanceOfPatternElement_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class_by_returnItems_reference_ReturnBody(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"returnItems reference ReturnBody");
	find mustInstanceOfReturnBody_class(problem,interpretation,container);
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayInRelationreturnItems_reference_ReturnBody(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_ReturnItems_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"ReturnItems class");
	find mayInstanceOfReturnItems_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_value_reference_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"value reference MapLiteralEntry");
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationvalue_reference_MapLiteralEntry(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class_by_expression_reference_ReturnItem(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"expression reference ReturnItem");
	find mustInstanceOfReturnItem_class(problem,interpretation,container);
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayInRelationexpression_reference_ReturnItem(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_StringLiteral_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"StringLiteral class");
	find mayInstanceOfStringLiteral_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class_by_patterns_reference_Pattern(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"patterns reference Pattern");
	find mustInstanceOfPattern_class(problem,interpretation,container);
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayInRelationpatterns_reference_Pattern(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_PatternPart_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"PatternPart class");
	find mayInstanceOfPatternPart_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class_by_pattern_reference_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"pattern reference Match");
	find mustInstanceOfMatch_class(problem,interpretation,container);
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayInRelationpattern_reference_Match(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_Pattern_class(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"Pattern class");
	find mayInstanceOfPattern_class(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart_by_statement_reference_Cypher(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationInterpretation:PartialRelationInterpretation, typeInterpretation:PartialComplexTypeInterpretation,
	container:DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	PartialInterpretation.partialrelationinterpretation(interpretation,relationInterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationInterpretation,"statement reference Cypher");
	find mustInstanceOfCypher_class(problem,interpretation,container);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayInRelationstatement_reference_Cypher(problem,interpretation,container,newObject);
	find mustExist(problem, interpretation, container);
	neg find mustExist(problem, interpretation, newObject);
}
pattern createObject_SinglePartQuery_class_UndefinedPart(
	problem:LogicProblem, interpretation:PartialInterpretation,
	typeInterpretation:PartialComplexTypeInterpretation)
{
	find interpretation(problem,interpretation);
	neg find hasElementInContainment(problem,interpretation);
	PartialInterpretation.partialtypeinterpratation(interpretation,typeInterpretation);
	PartialComplexTypeInterpretation.interpretationOf.name(typeInterpretation,"SinglePartQuery class UndefinedPart");
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,newObject);
	find mayExist(problem, interpretation, newObject);
	neg find mustExist(problem, interpretation, newObject);
}

//////////
// 4.2 Type refinement
//////////
pattern refineTypeTo_Cypher_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Query_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_PropertyExpression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnBody_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_ReadingClause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableRef_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_QueryOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_NodePattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_NodeLabels_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Clause_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Literal_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_RegularQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfRegularQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItem_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_SingleQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
	neg find mustInstanceOfSingleQuery_class_UndefinedPart(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_MapLiteralEntry_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Statement_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfQuery_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_AllOptions_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfAllOptions_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_AnonymousPatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Expression_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfExpression_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Return_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReadingClause_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_VariableDeclaration_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Properties_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Match_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfReturn_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfMatch_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternElement_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfPatternElement_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_ReturnItems_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_StringLiteral_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableRef_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodePattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStringLiteral_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_PatternPart_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfAnonymousPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_Pattern_class(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfStatement_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}
pattern refineTypeTo_SinglePartQuery_class_UndefinedPart(problem:LogicProblem, interpretation:PartialInterpretation, element: DefinedElement) {
	find interpretation(problem,interpretation);
	PartialInterpretation.newElements(interpretation,element);
	find mayInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfMapLiteralEntry_class(problem,interpretation,element);
	neg find mustInstanceOfCypher_class(problem,interpretation,element);
	neg find mustInstanceOfPropertyExpression_class(problem,interpretation,element);
	neg find mustInstanceOfReturnBody_class(problem,interpretation,element);
	neg find mustInstanceOfVariableDeclaration_class(problem,interpretation,element);
	neg find mustInstanceOfProperties_class(problem,interpretation,element);
	neg find mustInstanceOfQueryOptions_class(problem,interpretation,element);
	neg find mustInstanceOfNodeLabels_class(problem,interpretation,element);
	neg find mustInstanceOfReturnItems_class(problem,interpretation,element);
	neg find mustInstanceOfClause_class(problem,interpretation,element);
	neg find mustInstanceOfPatternPart_class(problem,interpretation,element);
	neg find mustInstanceOfPattern_class(problem,interpretation,element);
	neg find mustInstanceOfSinglePartQuery_class_UndefinedPart(problem,interpretation,element);
	neg find mustInstanceOfReturnItem_class(problem,interpretation,element);
}

//////////
// 4.3 Relation refinement
//////////
pattern refineRelation_variableRef_reference_VariableRef(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"variableRef reference VariableRef");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableRef_class(problem,interpretation,from);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,to);
	find mayInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
	neg find mustInRelationvariableRef_reference_VariableRef(problem,interpretation,from,to);
}
pattern refineRelation_explain_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"explain attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationexplain_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_profile_attribute_AllOptions(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"profile attribute AllOptions");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfAllOptions_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
	neg find mustInRelationprofile_attribute_AllOptions(problem,interpretation,from,to);
}
pattern refineRelation_optional_attribute_Match(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"optional attribute Match");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMatch_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationoptional_attribute_Match(problem,interpretation,from,to);
	neg find mustInRelationoptional_attribute_Match(problem,interpretation,from,to);
}
pattern refineRelation_name_attribute_VariableDeclaration(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"name attribute VariableDeclaration");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfVariableDeclaration_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
	neg find mustInRelationname_attribute_VariableDeclaration(problem,interpretation,from,to);
}
pattern refineRelation_key_attribute_MapLiteralEntry(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"key attribute MapLiteralEntry");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfMapLiteralEntry_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
	neg find mustInRelationkey_attribute_MapLiteralEntry(problem,interpretation,from,to);
}
pattern refineRelation_value_attribute_StringLiteral(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"value attribute StringLiteral");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfStringLiteral_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
	neg find mustInRelationvalue_attribute_StringLiteral(problem,interpretation,from,to);
}
pattern refineRelation_return_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"return attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationreturn_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationreturn_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_distinct_attribute_Return(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"distinct attribute Return");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturn_class(problem,interpretation,from);
	BooleanElement(to);
	find mayInRelationdistinct_attribute_Return(problem,interpretation,from,to);
	neg find mustInRelationdistinct_attribute_Return(problem,interpretation,from,to);
}
pattern refineRelation_all_attribute_ReturnItems(
	problem:LogicProblem, interpretation:PartialInterpretation,
	relationIterpretation:PartialRelationInterpretation,
	from: DefinedElement, to: DefinedElement)
{
	find interpretation(problem,interpretation);
	PartialInterpretation.partialrelationinterpretation(interpretation,relationIterpretation);
	PartialRelationInterpretation.interpretationOf.name(relationIterpretation,"all attribute ReturnItems");
	find mustExist(problem, interpretation, from);
	find mustExist(problem, interpretation, to);
	find mustInstanceOfReturnItems_class(problem,interpretation,from);
	StringElement(to);
	find mayInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
	neg find mustInRelationall_attribute_ReturnItems(problem,interpretation,from,to);
}
